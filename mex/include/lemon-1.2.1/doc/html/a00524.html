<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LEMON: Map Adaptors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Map Adaptors<br/>
<small>
[<a class="el" href="a00522.html">Maps</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This group contains map adaptors that are used to create "implicit" maps from other maps.</p>
<p>Most of them are <a class="el" href="a00269.html">read-only maps</a>. They can make arithmetic and logical operations between one or two maps (negation, shifting, addition, multiplication, logical 'and', 'or', 'not' etc.) or e.g. convert a map to another one of different Value type.</p>
<p>The typical usage of this classes is passing implicit maps to algorithms. If a function type algorithm is called then the function type map adaptors can be used comfortable. For example let's see the usage of map adaptors with the <code><a class="el" href="a00550.html#gac54dccfb4d46de3d6457ea3b1cd62671" title="Generates an EPS file from a graph.">graphToEps()</a></code> function. </p>
<div class="fragment"><pre class="fragment">  Color nodeColor(<span class="keywordtype">int</span> deg) {
    <span class="keywordflow">if</span> (deg &gt;= 2) {
      <span class="keywordflow">return</span> Color(0.5, 0.0, 0.5);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deg == 1) {
      <span class="keywordflow">return</span> Color(1.0, 0.5, 1.0);
    } <span class="keywordflow">else</span> {
      <span class="keywordflow">return</span> Color(0.0, 0.0, 0.0);
    }
  }

  Digraph::NodeMap&lt;int&gt; degree_map(graph);

  <a class="code" href="a00550.html#gac54dccfb4d46de3d6457ea3b1cd62671" title="Generates an EPS file from a graph.">graphToEps</a>(graph, <span class="stringliteral">&quot;graph.eps&quot;</span>)
    .coords(coords).scaleToA4().undirected()
    .nodeColors(composeMap(functorToMap(nodeColor), degree_map))
    .run();
</pre></div><p> The <code><a class="el" href="a00524.html#ga963668011830914036e0246f7ee060ac" title="Returns a FunctorToMap class.">functorToMap()</a></code> function makes an <code>int</code> to <code><a class="el" href="a00070.html">Color</a></code> map from the <code>nodeColor()</code> function. The <code><a class="el" href="a00524.html#ga168cb183ff15d3610151ab5044c70ce2" title="Returns a ComposeMap class.">composeMap()</a></code> compose the <code>degree_map</code> and the previously created map. The composed map is a proper function to get the color of each node.</p>
<p>The usage with class type algorithms is little bit harder. In this case the function type map adaptors can not be used, because the function map adaptors give back temporary objects. </p>
<div class="fragment"><pre class="fragment">  Digraph graph;

  <span class="keyword">typedef</span> Digraph::ArcMap&lt;double&gt; DoubleArcMap;
  DoubleArcMap length(graph);
  DoubleArcMap speed(graph);

  <span class="keyword">typedef</span> DivMap&lt;DoubleArcMap, DoubleArcMap&gt; TimeMap;
  TimeMap time(length, speed);

  Dijkstra&lt;Digraph, TimeMap&gt; <a class="code" href="a00531.html#ga6aa57523fe00e2b8fe2f5cd17dd15cea" title="Function-type interface for Dijkstra algorithm.">dijkstra</a>(graph, time);
  <a class="code" href="a00531.html#ga6aa57523fe00e2b8fe2f5cd17dd15cea" title="Function-type interface for Dijkstra algorithm.">dijkstra</a>.run(source, target);
</pre></div><p> We have a length map and a maximum speed map on the arcs of a digraph. The minimum time to pass the arc can be calculated as the division of the two maps which can be done implicitly with the <code><a class="el" href="a00117.html" title="Quotient of two maps.">DivMap</a></code> template class. We use the implicit minimum time map as the length map of the <code><a class="el" href="a00110.html" title="Dijkstra algorithm class.">Dijkstra</a></code> algorithm. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">ComposeMap&lt; M1, M2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Composition of two maps.  <a href="a00075.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">CombineMap&lt; M1, M2, F, V &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combination of two maps using an STL (binary) functor.  <a href="a00074.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">FunctorToMap&lt; F, K, V &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an STL style (unary) functor to a map.  <a href="a00147.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00214.html">MapToFunctor&lt; M &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a map to an STL style (unary) functor.  <a href="a00214.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">ConvertMap&lt; M, V &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map adaptor to convert the <code>Value</code> type of a map to another type using the default conversion.  <a href="a00085.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">ForkMap&lt; M1, M2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies all map setting operations to two maps.  <a href="a00142.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">AddMap&lt; M1, M2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum of two maps.  <a href="a00010.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00352.html">SubMap&lt; M1, M2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Difference of two maps.  <a href="a00352.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00228.html">MulMap&lt; M1, M2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Product of two maps.  <a href="a00228.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">DivMap&lt; M1, M2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quotient of two maps.  <a href="a00117.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00331.html">ShiftMap&lt; M, C &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shifts a map with a constant.  <a href="a00331.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00332.html">ShiftWriteMap&lt; M, C &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shifts a map with a constant (read-write version).  <a href="a00332.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html">ScaleMap&lt; M, C &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a map with a constant.  <a href="a00282.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00283.html">ScaleWriteMap&lt; M, C &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a map with a constant (read-write version).  <a href="a00283.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html">NegMap&lt; M &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negative of a map.  <a href="a00229.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00230.html">NegWriteMap&lt; M &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negative of a map (read-write version).  <a href="a00230.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">AbsMap&lt; M &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute value of a map.  <a href="a00008.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">AndMap&lt; M1, M2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logical 'and' of two maps.  <a href="a00014.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00246.html">OrMap&lt; M1, M2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logical 'or' of two maps.  <a href="a00246.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00242.html">NotMap&lt; M &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logical 'not' of a map.  <a href="a00242.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html">NotWriteMap&lt; M &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logical 'not' of a map (read-write version).  <a href="a00243.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">EqualMap&lt; M1, M2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combination of two maps using the <code>==</code> operator.  <a href="a00127.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00198.html">LessMap&lt; M1, M2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combination of two maps using the <code>&lt;</code> operator.  <a href="a00198.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ComposeMap&lt; M1, M2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga168cb183ff15d3610151ab5044c70ce2">composeMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00075.html" title="Composition of two maps.">ComposeMap</a></code> class.  <a href="#ga168cb183ff15d3610151ab5044c70ce2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 , typename F , typename V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">CombineMap&lt; M1, M2, F, V &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#gab2f07629cac63828dbdab26e754e0767">combineMap</a> (const M1 &amp;m1, const M2 &amp;m2, const F &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00074.html" title="Combination of two maps using an STL (binary) functor.">CombineMap</a></code> class.  <a href="#gab2f07629cac63828dbdab26e754e0767"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">FunctorToMap&lt; F, K, V &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga963668011830914036e0246f7ee060ac">functorToMap</a> (const F &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00147.html" title="Converts an STL style (unary) functor to a map.">FunctorToMap</a></code> class.  <a href="#ga963668011830914036e0246f7ee060ac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">MapToFunctor&lt; M &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga9141e0ff40567f9d640db2c22485c28a">mapToFunctor</a> (const M &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00214.html" title="Converts a map to an STL style (unary) functor.">MapToFunctor</a></code> class.  <a href="#ga9141e0ff40567f9d640db2c22485c28a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename V , typename M &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ConvertMap&lt; M, V &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga47b4b4266339a3a8178c64d70958246d">convertMap</a> (const M &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00085.html" title="Map adaptor to convert the Value type of a map to another type using the default conversion.">ConvertMap</a></code> class.  <a href="#ga47b4b4266339a3a8178c64d70958246d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForkMap&lt; M1, M2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga09ff2fa37a6ca994c6d79a21942a50d2">forkMap</a> (M1 &amp;m1, M2 &amp;m2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00142.html" title="Applies all map setting operations to two maps.">ForkMap</a></code> class.  <a href="#ga09ff2fa37a6ca994c6d79a21942a50d2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">AddMap&lt; M1, M2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#gabb8ca6bab7c32b12e1671497ac774d5d">addMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an <code><a class="el" href="a00010.html" title="Sum of two maps.">AddMap</a></code> class.  <a href="#gabb8ca6bab7c32b12e1671497ac774d5d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">SubMap&lt; M1, M2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#gad1a93a51897caa4c921635a9fa51cef9">subMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00352.html" title="Difference of two maps.">SubMap</a></code> class.  <a href="#gad1a93a51897caa4c921635a9fa51cef9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">MulMap&lt; M1, M2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#gae53cd3bc6adcb7381407f33f065142a5">mulMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00228.html" title="Product of two maps.">MulMap</a></code> class.  <a href="#gae53cd3bc6adcb7381407f33f065142a5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DivMap&lt; M1, M2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga5ed3699166ac2cb68e69d4722ebc4df7">divMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00117.html" title="Quotient of two maps.">DivMap</a></code> class.  <a href="#ga5ed3699166ac2cb68e69d4722ebc4df7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ShiftMap&lt; M, C &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga179d41790ba45a63238666fd8437f763">shiftMap</a> (const M &amp;m, const C &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00331.html" title="Shifts a map with a constant.">ShiftMap</a></code> class.  <a href="#ga179d41790ba45a63238666fd8437f763"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ShiftWriteMap&lt; M, C &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#gad25e797238b5fe75bec91c1937c2f99d">shiftWriteMap</a> (M &amp;m, const C &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00332.html" title="Shifts a map with a constant (read-write version).">ShiftWriteMap</a></code> class.  <a href="#gad25e797238b5fe75bec91c1937c2f99d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ScaleMap&lt; M, C &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga50af6b7bd9b56fa08bdda3e4e84a9541">scaleMap</a> (const M &amp;m, const C &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00282.html" title="Scales a map with a constant.">ScaleMap</a></code> class.  <a href="#ga50af6b7bd9b56fa08bdda3e4e84a9541"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ScaleWriteMap&lt; M, C &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#gaa23c144c639d693478a6660cf388cf87">scaleWriteMap</a> (M &amp;m, const C &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00283.html" title="Scales a map with a constant (read-write version).">ScaleWriteMap</a></code> class.  <a href="#gaa23c144c639d693478a6660cf388cf87"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NegMap&lt; M &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga8d293b8674b498629cd4f5cd73431330">negMap</a> (const M &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00229.html" title="Negative of a map.">NegMap</a></code> class.  <a href="#ga8d293b8674b498629cd4f5cd73431330"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NegWriteMap&lt; M &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#gab8b568a6081147ff0df4d6720095a80d">negWriteMap</a> (M &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00230.html" title="Negative of a map (read-write version).">NegWriteMap</a></code> class.  <a href="#gab8b568a6081147ff0df4d6720095a80d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">AbsMap&lt; M &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#gaa3f892034fca5ba41151aebdba69e41c">absMap</a> (const M &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an <code><a class="el" href="a00008.html" title="Absolute value of a map.">AbsMap</a></code> class.  <a href="#gaa3f892034fca5ba41151aebdba69e41c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">AndMap&lt; M1, M2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga33f98a39433f441c03b1945d2de4403f">andMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an <code><a class="el" href="a00014.html" title="Logical &#39;and&#39; of two maps.">AndMap</a></code> class.  <a href="#ga33f98a39433f441c03b1945d2de4403f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OrMap&lt; M1, M2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga87d0aa36f6a8a59b23f692d03376761d">orMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an <code><a class="el" href="a00246.html" title="Logical &#39;or&#39; of two maps.">OrMap</a></code> class.  <a href="#ga87d0aa36f6a8a59b23f692d03376761d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NotMap&lt; M &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga03804878900222f6828e1ee4f921a083">notMap</a> (const M &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00242.html" title="Logical &#39;not&#39; of a map.">NotMap</a></code> class.  <a href="#ga03804878900222f6828e1ee4f921a083"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">NotWriteMap&lt; M &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga6d3efe02540c14e706214993a061111e">notWriteMap</a> (M &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a <code><a class="el" href="a00243.html" title="Logical &#39;not&#39; of a map (read-write version).">NotWriteMap</a></code> class.  <a href="#ga6d3efe02540c14e706214993a061111e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">EqualMap&lt; M1, M2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#gab064d43b2f6ccb5ea5fe99ba5f53015d">equalMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an <code><a class="el" href="a00127.html" title="Combination of two maps using the == operator.">EqualMap</a></code> class.  <a href="#gab064d43b2f6ccb5ea5fe99ba5f53015d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename M1 , typename M2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LessMap&lt; M1, M2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00524.html#ga6d57040954dfe0188f02540fe8cf3319">lessMap</a> (const M1 &amp;m1, const M2 &amp;m2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an <code><a class="el" href="a00198.html" title="Combination of two maps using the &lt; operator.">LessMap</a></code> class.  <a href="#ga6d57040954dfe0188f02540fe8cf3319"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga168cb183ff15d3610151ab5044c70ce2"></a><!-- doxytag: member="lemon::ComposeMap::composeMap" ref="ga168cb183ff15d3610151ab5044c70ce2" args="(const M1 &amp;m1, const M2 &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ComposeMap&lt; M1, M2 &gt; composeMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00075.html" title="Composition of two maps.">ComposeMap</a></code> class.</p>
<p>If <code>m1</code> and <code>m2</code> are maps and the <code>Value</code> type of <code>m2</code> is convertible to the <code>Key</code> of <code>m1</code>, then <code>composeMap(m1,m2)[x]</code> will be equal to <code>m1[m2[x]]</code>. </p>

</div>
</div>
<a class="anchor" id="gab2f07629cac63828dbdab26e754e0767"></a><!-- doxytag: member="lemon::CombineMap::combineMap" ref="gab2f07629cac63828dbdab26e754e0767" args="(const M1 &amp;m1, const M2 &amp;m2, const F &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CombineMap&lt; M1, M2, F, V &gt; combineMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00074.html" title="Combination of two maps using an STL (binary) functor.">CombineMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>double</code> values, then </p>
<div class="fragment"><pre class="fragment">   <a class="code" href="a00524.html#gab2f07629cac63828dbdab26e754e0767" title="Returns a CombineMap class.">combineMap</a>(m1,m2,std::plus&lt;double&gt;())
</pre></div><p> is equivalent to </p>
<div class="fragment"><pre class="fragment">   addMap(m1,m2)
</pre></div><p>This function is specialized for adaptable binary function classes and C++ functions. </p>

</div>
</div>
<a class="anchor" id="ga963668011830914036e0246f7ee060ac"></a><!-- doxytag: member="lemon::FunctorToMap::functorToMap" ref="ga963668011830914036e0246f7ee060ac" args="(const F &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FunctorToMap&lt; F, K, V &gt; functorToMap </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00147.html" title="Converts an STL style (unary) functor to a map.">FunctorToMap</a></code> class.</p>
<p>This function is specialized for adaptable binary function classes and C++ functions. </p>

</div>
</div>
<a class="anchor" id="ga9141e0ff40567f9d640db2c22485c28a"></a><!-- doxytag: member="lemon::MapToFunctor::mapToFunctor" ref="ga9141e0ff40567f9d640db2c22485c28a" args="(const M &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MapToFunctor&lt; M &gt; mapToFunctor </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00214.html" title="Converts a map to an STL style (unary) functor.">MapToFunctor</a></code> class. </p>

</div>
</div>
<a class="anchor" id="ga47b4b4266339a3a8178c64d70958246d"></a><!-- doxytag: member="lemon::ConvertMap::convertMap" ref="ga47b4b4266339a3a8178c64d70958246d" args="(const M &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConvertMap&lt; M, V &gt; convertMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00085.html" title="Map adaptor to convert the Value type of a map to another type using the default conversion.">ConvertMap</a></code> class. </p>

</div>
</div>
<a class="anchor" id="ga09ff2fa37a6ca994c6d79a21942a50d2"></a><!-- doxytag: member="lemon::ForkMap::forkMap" ref="ga09ff2fa37a6ca994c6d79a21942a50d2" args="(M1 &amp;m1, M2 &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForkMap&lt; M1, M2 &gt; forkMap </td>
          <td>(</td>
          <td class="paramtype">M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00142.html" title="Applies all map setting operations to two maps.">ForkMap</a></code> class. </p>

</div>
</div>
<a class="anchor" id="gabb8ca6bab7c32b12e1671497ac774d5d"></a><!-- doxytag: member="lemon::AddMap::addMap" ref="gabb8ca6bab7c32b12e1671497ac774d5d" args="(const M1 &amp;m1, const M2 &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AddMap&lt; M1, M2 &gt; addMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00010.html" title="Sum of two maps.">AddMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>double</code> values, then <code>addMap(m1,m2)[x]</code> will be equal to <code>m1[x]+m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="gad1a93a51897caa4c921635a9fa51cef9"></a><!-- doxytag: member="lemon::SubMap::subMap" ref="gad1a93a51897caa4c921635a9fa51cef9" args="(const M1 &amp;m1, const M2 &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SubMap&lt; M1, M2 &gt; subMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00352.html" title="Difference of two maps.">SubMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>double</code> values, then <code>subMap(m1,m2)[x]</code> will be equal to <code>m1[x]-m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="gae53cd3bc6adcb7381407f33f065142a5"></a><!-- doxytag: member="lemon::MulMap::mulMap" ref="gae53cd3bc6adcb7381407f33f065142a5" args="(const M1 &amp;m1, const M2 &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MulMap&lt; M1, M2 &gt; mulMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00228.html" title="Product of two maps.">MulMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>double</code> values, then <code>mulMap(m1,m2)[x]</code> will be equal to <code>m1[x]*m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga5ed3699166ac2cb68e69d4722ebc4df7"></a><!-- doxytag: member="lemon::DivMap::divMap" ref="ga5ed3699166ac2cb68e69d4722ebc4df7" args="(const M1 &amp;m1, const M2 &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DivMap&lt; M1, M2 &gt; divMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00117.html" title="Quotient of two maps.">DivMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>double</code> values, then <code>divMap(m1,m2)[x]</code> will be equal to <code>m1[x]/m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga179d41790ba45a63238666fd8437f763"></a><!-- doxytag: member="lemon::ShiftMap::shiftMap" ref="ga179d41790ba45a63238666fd8437f763" args="(const M &amp;m, const C &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ShiftMap&lt; M, C &gt; shiftMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00331.html" title="Shifts a map with a constant.">ShiftMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values and <code>v</code> is <code>double</code>, then <code>shiftMap(m,v)[x]</code> will be equal to <code>m[x]+v</code>. </p>

</div>
</div>
<a class="anchor" id="gad25e797238b5fe75bec91c1937c2f99d"></a><!-- doxytag: member="lemon::ShiftWriteMap::shiftWriteMap" ref="gad25e797238b5fe75bec91c1937c2f99d" args="(M &amp;m, const C &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ShiftWriteMap&lt; M, C &gt; shiftWriteMap </td>
          <td>(</td>
          <td class="paramtype">M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00332.html" title="Shifts a map with a constant (read-write version).">ShiftWriteMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values and <code>v</code> is <code>double</code>, then <code>shiftWriteMap(m,v)[x]</code> will be equal to <code>m[x]+v</code>. Moreover it makes also possible to write the map. </p>

</div>
</div>
<a class="anchor" id="ga50af6b7bd9b56fa08bdda3e4e84a9541"></a><!-- doxytag: member="lemon::ScaleMap::scaleMap" ref="ga50af6b7bd9b56fa08bdda3e4e84a9541" args="(const M &amp;m, const C &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScaleMap&lt; M, C &gt; scaleMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00282.html" title="Scales a map with a constant.">ScaleMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values and <code>v</code> is <code>double</code>, then <code>scaleMap(m,v)[x]</code> will be equal to <code>v*m[x]</code>. </p>

</div>
</div>
<a class="anchor" id="gaa23c144c639d693478a6660cf388cf87"></a><!-- doxytag: member="lemon::ScaleWriteMap::scaleWriteMap" ref="gaa23c144c639d693478a6660cf388cf87" args="(M &amp;m, const C &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScaleWriteMap&lt; M, C &gt; scaleWriteMap </td>
          <td>(</td>
          <td class="paramtype">M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00283.html" title="Scales a map with a constant (read-write version).">ScaleWriteMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values and <code>v</code> is <code>double</code>, then <code>scaleWriteMap(m,v)[x]</code> will be equal to <code>v*m[x]</code>. Moreover it makes also possible to write the map. </p>

</div>
</div>
<a class="anchor" id="ga8d293b8674b498629cd4f5cd73431330"></a><!-- doxytag: member="lemon::NegMap::negMap" ref="ga8d293b8674b498629cd4f5cd73431330" args="(const M &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NegMap&lt; M &gt; negMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00229.html" title="Negative of a map.">NegMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values, then <code>negMap(m)[x]</code> will be equal to <code>-m[x]</code>. </p>

</div>
</div>
<a class="anchor" id="gab8b568a6081147ff0df4d6720095a80d"></a><!-- doxytag: member="lemon::NegWriteMap::negWriteMap" ref="gab8b568a6081147ff0df4d6720095a80d" args="(M &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NegWriteMap&lt; M &gt; negWriteMap </td>
          <td>(</td>
          <td class="paramtype">M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00230.html" title="Negative of a map (read-write version).">NegWriteMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values, then <code>negWriteMap(m)[x]</code> will be equal to <code>-m[x]</code>. Moreover it makes also possible to write the map. </p>

</div>
</div>
<a class="anchor" id="gaa3f892034fca5ba41151aebdba69e41c"></a><!-- doxytag: member="lemon::AbsMap::absMap" ref="gaa3f892034fca5ba41151aebdba69e41c" args="(const M &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AbsMap&lt; M &gt; absMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00008.html" title="Absolute value of a map.">AbsMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>double</code> values, then <code>absMap(m)[x]</code> will be equal to <code>m[x]</code> if it is positive or zero and <code>-m[x]</code> if <code>m[x]</code> is negative. </p>

</div>
</div>
<a class="anchor" id="ga33f98a39433f441c03b1945d2de4403f"></a><!-- doxytag: member="lemon::AndMap::andMap" ref="ga33f98a39433f441c03b1945d2de4403f" args="(const M1 &amp;m1, const M2 &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AndMap&lt; M1, M2 &gt; andMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00014.html" title="Logical &#39;and&#39; of two maps.">AndMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>bool</code> values, then <code>andMap(m1,m2)[x]</code> will be equal to <code>m1[x]&amp;&amp;m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga87d0aa36f6a8a59b23f692d03376761d"></a><!-- doxytag: member="lemon::OrMap::orMap" ref="ga87d0aa36f6a8a59b23f692d03376761d" args="(const M1 &amp;m1, const M2 &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OrMap&lt; M1, M2 &gt; orMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00246.html" title="Logical &#39;or&#39; of two maps.">OrMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are both maps with <code>bool</code> values, then <code>orMap(m1,m2)[x]</code> will be equal to <code>m1[x]||m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga03804878900222f6828e1ee4f921a083"></a><!-- doxytag: member="lemon::NotMap::notMap" ref="ga03804878900222f6828e1ee4f921a083" args="(const M &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NotMap&lt; M &gt; notMap </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00242.html" title="Logical &#39;not&#39; of a map.">NotMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>bool</code> values, then <code>notMap(m)[x]</code> will be equal to <code>!m[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga6d3efe02540c14e706214993a061111e"></a><!-- doxytag: member="lemon::NotWriteMap::notWriteMap" ref="ga6d3efe02540c14e706214993a061111e" args="(M &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NotWriteMap&lt; M &gt; notWriteMap </td>
          <td>(</td>
          <td class="paramtype">M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns a <code><a class="el" href="a00243.html" title="Logical &#39;not&#39; of a map (read-write version).">NotWriteMap</a></code> class.</p>
<p>For example, if <code>m</code> is a map with <code>bool</code> values, then <code>notWriteMap(m)[x]</code> will be equal to <code>!m[x]</code>. Moreover it makes also possible to write the map. </p>

</div>
</div>
<a class="anchor" id="gab064d43b2f6ccb5ea5fe99ba5f53015d"></a><!-- doxytag: member="lemon::EqualMap::equalMap" ref="gab064d43b2f6ccb5ea5fe99ba5f53015d" args="(const M1 &amp;m1, const M2 &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EqualMap&lt; M1, M2 &gt; equalMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00127.html" title="Combination of two maps using the == operator.">EqualMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are maps with keys and values of the same type, then <code>equalMap(m1,m2)[x]</code> will be equal to <code>m1[x]==m2[x]</code>. </p>

</div>
</div>
<a class="anchor" id="ga6d57040954dfe0188f02540fe8cf3319"></a><!-- doxytag: member="lemon::LessMap::lessMap" ref="ga6d57040954dfe0188f02540fe8cf3319" args="(const M1 &amp;m1, const M2 &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LessMap&lt; M1, M2 &gt; lessMap </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M2 &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function just returns an <code><a class="el" href="a00198.html" title="Combination of two maps using the &lt; operator.">LessMap</a></code> class.</p>
<p>For example, if <code>m1</code> and <code>m2</code> are maps with keys and values of the same type, then <code>lessMap(m1,m2)[x]</code> will be equal to <code>m1[x]&lt;m2[x]</code>. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
