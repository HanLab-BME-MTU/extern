<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LEMON: DfsVisit&lt; GR, VS, TR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a00496.html">lemon</a>      </li>
      <li><a class="el" href="a00098.html">DfsVisit&lt; GR, VS, TR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>DfsVisit&lt; GR, VS, TR &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00530.html">Graph Search</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="lemon::DfsVisit" --><hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename GR, typename VS, typename TR&gt;<br/>
 class lemon::DfsVisit&lt; GR, VS, TR &gt;</h3>

<p>This class provides an efficient implementation of the DFS algorithm with visitor interface.</p>
<p>The <a class="el" href="a00098.html" title="DFS algorithm class with visitor interface.">DfsVisit</a> class provides an alternative interface to the <a class="el" href="a00096.html" title="DFS algorithm class.">Dfs</a> class. It works with callback mechanism, the <a class="el" href="a00098.html" title="DFS algorithm class with visitor interface.">DfsVisit</a> object calls the member functions of the <code>Visitor</code> class on every DFS event.</p>
<p>This interface of the DFS algorithm should be used in special cases when extra actions have to be performed in connection with certain events of the DFS algorithm. Otherwise consider to use <a class="el" href="a00096.html" title="DFS algorithm class.">Dfs</a> or <a class="el" href="a00530.html#ga1926710bf80700bdeab0fb2e16830999" title="Function-type interface for DFS algorithm.">dfs()</a> instead.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>GR</em>&nbsp;</td><td>The type of the digraph the algorithm runs on. The default type is <a class="el" href="a00203.html">ListDigraph</a>. The value of GR is not used directly by <a class="el" href="a00098.html">DfsVisit</a>, it is only passed to <a class="el" href="a00099.html">DfsVisitDefaultTraits</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VS</em>&nbsp;</td><td>The Visitor type that is used by the algorithm. <a class="el" href="a00100.html">DfsVisitor&lt;GR&gt;</a> is an empty visitor, which does not observe the DFS events. If you want to observe the DFS events, you should implement your own visitor class. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TR</em>&nbsp;</td><td>The traits class that defines various types used by the algorithm. By default, it is <a class="el" href="a00099.html">DfsVisitDefaultTraits&lt;GR&gt;</a>. In most cases, this parameter should not be set directly, consider to use the named template parameters instead. </td></tr>
  </table>
  </dd>
</dl>

<p><code>#include &lt;lemon/dfs.h&gt;</code></p>

<p><a href="a00682.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00323.html">SetReachedMap</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab157e5452122f7a7f73dfda5ed931d69"></a><!-- doxytag: member="lemon::DfsVisit::Traits" ref="ab157e5452122f7a7f73dfda5ed931d69" args="" -->
typedef TR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#ab157e5452122f7a7f73dfda5ed931d69">Traits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The traits class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6928feef02be4f2a184775d19dc6373"></a><!-- doxytag: member="lemon::DfsVisit::Digraph" ref="aa6928feef02be4f2a184775d19dc6373" args="" -->
typedef Traits::Digraph&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#aa6928feef02be4f2a184775d19dc6373">Digraph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the digraph the algorithm runs on. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bece3b7c0b0189b735a408e533f3d73"></a><!-- doxytag: member="lemon::DfsVisit::Visitor" ref="a3bece3b7c0b0189b735a408e533f3d73" args="" -->
typedef VS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a3bece3b7c0b0189b735a408e533f3d73">Visitor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The visitor type used by the algorithm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90221be1b9274785db2188548354d2aa"></a><!-- doxytag: member="lemon::DfsVisit::ReachedMap" ref="a90221be1b9274785db2188548354d2aa" args="" -->
typedef Traits::ReachedMap&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a90221be1b9274785db2188548354d2aa">ReachedMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the map that indicates which nodes are reached. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#ab2606d461569b07df9a904f66aadfa82">DfsVisit</a> (const <a class="el" href="a00098.html#aa6928feef02be4f2a184775d19dc6373">Digraph</a> &amp;digraph, <a class="el" href="a00098.html#a3bece3b7c0b0189b735a408e533f3d73">Visitor</a> &amp;visitor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#ab2606d461569b07df9a904f66aadfa82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b3719df6ef9a6c93579c6b48309fb9a"></a><!-- doxytag: member="lemon::DfsVisit::~DfsVisit" ref="a1b3719df6ef9a6c93579c6b48309fb9a" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a1b3719df6ef9a6c93579c6b48309fb9a">~DfsVisit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00098.html">DfsVisit</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a534f6847b03afac5b47af994d4f6666b">reachedMap</a> (<a class="el" href="a00098.html#a90221be1b9274785db2188548354d2aa">ReachedMap</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the map that indicates which nodes are reached.  <a href="#a534f6847b03afac5b47af994d4f6666b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution Control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd80b908dd00a6c6f28e1b1ee2d5fd269"></a> The simplest way to execute the DFS algorithm is to use one of the member functions called <a class="el" href="a00098.html#ae3f0682c90a4e8a23c259943e899402e">run()</a>.<br/>
 If you need better control on the execution, you have to call <a class="el" href="a00098.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> first, then you can add a source node with <a class="el" href="a00098.html#ac785b6504b67a963b4c20bae90441a77">addSource()</a> and perform the actual computation with <a class="el" href="a00098.html#a60de64d75454385b23995437f1d72669">start()</a>. This procedure can be repeated if there are nodes that have not been reached. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#ac785b6504b67a963b4c20bae90441a77">addSource</a> (Node s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a new source node.  <a href="#ac785b6504b67a963b4c20bae90441a77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Arc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a773a0c2fc82672c4dd7af546908b8a5c">processNextArc</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes the next arc.  <a href="#a773a0c2fc82672c4dd7af546908b8a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Arc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a22c9301865dd8c7dffe8e48cae77823f">nextArc</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Next arc to be processed.  <a href="#a22c9301865dd8c7dffe8e48cae77823f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#ab6dcd2be02feaff0a95c21824e805445">emptyQueue</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>false</code> if there are nodes to be processed.  <a href="#ab6dcd2be02feaff0a95c21824e805445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a942d30059e28f60ba6dd1944ab8e416e">queueSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of the nodes to be processed.  <a href="#a942d30059e28f60ba6dd1944ab8e416e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a60de64d75454385b23995437f1d72669">start</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the algorithm.  <a href="#a60de64d75454385b23995437f1d72669"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a8b8de9dfc16e4b3cb6b38733e82f6449">start</a> (Node t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the algorithm until the given target node is reached.  <a href="#a8b8de9dfc16e4b3cb6b38733e82f6449"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename AM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Arc&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00098.html#ade3539cfc4dd0f5cf01e91b2ebd09b78">start</a> (const AM &amp;am)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the algorithm until a condition is met.  <a href="#ade3539cfc4dd0f5cf01e91b2ebd09b78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#ae3f0682c90a4e8a23c259943e899402e">run</a> (Node s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runs the algorithm from the given source node.  <a href="#ae3f0682c90a4e8a23c259943e899402e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#ad2c3c4217c98b58a8618397d65d400c8">run</a> (Node s, Node t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the DFS path between <code>s</code> and <code>t</code>.  <a href="#ad2c3c4217c98b58a8618397d65d400c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#a13a43e6d814de94978c515cb084873b1">run</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runs the algorithm to visit all nodes in the digraph.  <a href="#a13a43e6d814de94978c515cb084873b1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9842fe246fad3ca12bcafafc2b70d75"></a> The results of the DFS algorithm can be obtained using these functions.<br/>
 Either <a class="el" href="a00098.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00098.html#a60de64d75454385b23995437f1d72669">start()</a> should be called before using them. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html#abb98c427556a2afe917e41fe8d3e75bf">reached</a> (Node v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the given node is reached from the root(s).  <a href="#abb98c427556a2afe917e41fe8d3e75bf"></a><br/></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab2606d461569b07df9a904f66aadfa82"></a><!-- doxytag: member="lemon::DfsVisit::DfsVisit" ref="ab2606d461569b07df9a904f66aadfa82" args="(const Digraph &amp;digraph, Visitor &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00098.html">DfsVisit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00098.html#aa6928feef02be4f2a184775d19dc6373">Digraph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>digraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00098.html#a3bece3b7c0b0189b735a408e533f3d73">Visitor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>digraph</em>&nbsp;</td><td>The digraph the algorithm runs on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visitor</em>&nbsp;</td><td>The visitor object of the algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a534f6847b03afac5b47af994d4f6666b"></a><!-- doxytag: member="lemon::DfsVisit::reachedMap" ref="a534f6847b03afac5b47af994d4f6666b" args="(ReachedMap &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00098.html">DfsVisit</a>&amp; reachedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00098.html#a90221be1b9274785db2188548354d2aa">ReachedMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the map that indicates which nodes are reached. If you don't use this function before calling <a class="el" href="a00098.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00098.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, an instance will be allocated automatically. The destructor deallocates this automatically allocated map, of course. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a02fd73d861ef2e4aabb38c0c9ff82947"></a><!-- doxytag: member="lemon::DfsVisit::init" ref="a02fd73d861ef2e4aabb38c0c9ff82947" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the internal data structures. </p>

</div>
</div>
<a class="anchor" id="ac785b6504b67a963b4c20bae90441a77"></a><!-- doxytag: member="lemon::DfsVisit::addSource" ref="ac785b6504b67a963b4c20bae90441a77" args="(Node s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addSource </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a new source node to the set of nodes to be processed.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The stack must be empty. Otherwise the algorithm gives wrong results. (One of the outgoing arcs of all the source nodes except for the last one will not be visited and distances will also be wrong.) </dd></dl>

</div>
</div>
<a class="anchor" id="a773a0c2fc82672c4dd7af546908b8a5c"></a><!-- doxytag: member="lemon::DfsVisit::processNextArc" ref="a773a0c2fc82672c4dd7af546908b8a5c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Arc processNextArc </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Processes the next arc.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The processed arc.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The stack must not be empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a22c9301865dd8c7dffe8e48cae77823f"></a><!-- doxytag: member="lemon::DfsVisit::nextArc" ref="a22c9301865dd8c7dffe8e48cae77823f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Arc nextArc </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Next arc to be processed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next arc to be processed or INVALID if the stack is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6dcd2be02feaff0a95c21824e805445"></a><!-- doxytag: member="lemon::DfsVisit::emptyQueue" ref="ab6dcd2be02feaff0a95c21824e805445" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool emptyQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>false</code> if there are nodes to be processed in the queue (stack). </p>

</div>
</div>
<a class="anchor" id="a942d30059e28f60ba6dd1944ab8e416e"></a><!-- doxytag: member="lemon::DfsVisit::queueSize" ref="a942d30059e28f60ba6dd1944ab8e416e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queueSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of the nodes to be processed in the queue (stack). </p>

</div>
</div>
<a class="anchor" id="a60de64d75454385b23995437f1d72669"></a><!-- doxytag: member="lemon::DfsVisit::start" ref="a60de64d75454385b23995437f1d72669" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes the algorithm.</p>
<p>This method runs the DFS algorithm from the root node in order to compute the DFS path to each node.</p>
<p>The algorithm computes</p>
<ul>
<li>the DFS tree,</li>
<li>the distance of each node from the root in the DFS tree.</li>
</ul>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00098.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called and a root node should be added with <a class="el" href="a00098.html#ac785b6504b67a963b4c20bae90441a77" title="Adds a new source node.">addSource()</a> before using this function.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><code>d.start()</code> is just a shortcut of the following code. <div class="fragment"><pre class="fragment">   <span class="keywordflow">while</span> ( !d.emptyQueue() ) {
     d.processNextArc();
   }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8de9dfc16e4b3cb6b38733e82f6449"></a><!-- doxytag: member="lemon::DfsVisit::start" ref="a8b8de9dfc16e4b3cb6b38733e82f6449" args="(Node t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes the algorithm until the given target node is reached.</p>
<p>This method runs the DFS algorithm from the root node in order to compute the DFS path to <code>t</code>.</p>
<p>The algorithm computes</p>
<ul>
<li>the DFS path to <code>t</code>,</li>
<li>the distance of <code>t</code> from the root in the DFS tree.</li>
</ul>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00098.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called and a root node should be added with <a class="el" href="a00098.html#ac785b6504b67a963b4c20bae90441a77" title="Adds a new source node.">addSource()</a> before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ade3539cfc4dd0f5cf01e91b2ebd09b78"></a><!-- doxytag: member="lemon::DfsVisit::start" ref="ade3539cfc4dd0f5cf01e91b2ebd09b78" args="(const AM &amp;am)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Arc start </td>
          <td>(</td>
          <td class="paramtype">const AM &amp;&nbsp;</td>
          <td class="paramname"> <em>am</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes the algorithm until a condition is met.</p>
<p>This method runs the DFS algorithm from the root node until an arc <code>a</code> with <code>am[a]</code> true is found.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>am</em>&nbsp;</td><td>A <code>bool</code> (or convertible) arc map. The algorithm will stop when it reaches an arc <code>a</code> with <code>am[a]</code> true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The reached arc <code>a</code> with <code>am[a]</code> true or <code>INVALID</code> if no such arc was found.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00098.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called and a root node should be added with <a class="el" href="a00098.html#ac785b6504b67a963b4c20bae90441a77" title="Adds a new source node.">addSource()</a> before using this function.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Contrary to <a class="el" href="a00040.html">Bfs</a> and <a class="el" href="a00110.html">Dijkstra</a>, <code>am</code> is an arc map, not a node map. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3f0682c90a4e8a23c259943e899402e"></a><!-- doxytag: member="lemon::DfsVisit::run" ref="ae3f0682c90a4e8a23c259943e899402e" args="(Node s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method runs the DFS algorithm from node <code>s</code>. in order to compute the DFS path to each node.</p>
<p>The algorithm computes</p>
<ul>
<li>the DFS tree,</li>
<li>the distance of each node from the root in the DFS tree.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd><code>d.run(s)</code> is just a shortcut of the following code. <div class="fragment"><pre class="fragment">          d.init();
          d.addSource(s);
          d.start();
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2c3c4217c98b58a8618397d65d400c8"></a><!-- doxytag: member="lemon::DfsVisit::run" ref="ad2c3c4217c98b58a8618397d65d400c8" args="(Node s, Node t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool run </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method runs the DFS algorithm from node <code>s</code> in order to compute the DFS path to node <code>t</code> (it stops searching when <code>t</code> is processed).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <code>t</code> is reachable form <code>s</code>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Apart from the return value, <code>d.run(s,t)</code> is just a shortcut of the following code. <div class="fragment"><pre class="fragment">          d.init();
          d.addSource(s);
          d.start(t);
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="a13a43e6d814de94978c515cb084873b1"></a><!-- doxytag: member="lemon::DfsVisit::run" ref="a13a43e6d814de94978c515cb084873b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method runs the DFS algorithm in order to visit all nodes in the digraph.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><code>d.run()</code> is just a shortcut of the following code. <div class="fragment"><pre class="fragment">          d.init();
          <span class="keywordflow">for</span> (NodeIt n(digraph); n != <a class="code" href="a00496.html#a0f04de8e6be7bc21ed685c651571d9fe" title="Invalid iterators.">INVALID</a>; ++n) {
            <span class="keywordflow">if</span> (!d.reached(n)) {
              d.addSource(n);
              d.start();
            }
          }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="abb98c427556a2afe917e41fe8d3e75bf"></a><!-- doxytag: member="lemon::DfsVisit::reached" ref="abb98c427556a2afe917e41fe8d3e75bf" args="(Node v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reached </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>true</code> if <code>v</code> is reached from the root(s).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00098.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00098.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
