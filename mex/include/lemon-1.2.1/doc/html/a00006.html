<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LEMON: Named Parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Named Parameters </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="named-func-param"></a>
Named Function Parameters</h2>
<p>Several modern languages provide a convenient way to refer the function parameters by name also when you call the function. It is especially comfortable in case of a function having tons of parameters with natural default values. Sadly, C++ lack this amenity.</p>
<p>However, with a crafty trick and with some little inconvenience, it is possible to emulate is. The example below shows how to do it.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>namedFn
{
  <span class="keywordtype">int</span> _id;
  <span class="keywordtype">double</span> _val;
  <span class="keywordtype">int</span> _dim;

  <span class="keyword">public</span>:
  namedFn() : _id(0), _val(1), _dim(2) {}
  namedFn&amp; id(<span class="keywordtype">int</span> p)     { _id  = p ; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
  namedFn&amp; val(<span class="keywordtype">double</span> p) { _val = p ; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
  namedFn&amp; dim(<span class="keywordtype">int</span> p)    { _dim = p ; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }

  run() {
    std::cout &lt;&lt; <span class="stringliteral">&quot;Here comes the function itself\n&quot;</span> &lt;&lt;
              &lt;&lt; <span class="stringliteral">&quot;With parameters &quot;</span>
              &lt;&lt; _id &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; _val &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; _dim &lt;&lt; std::endl;
  }
};
</pre></div><p>Then you can use it like this.</p>
<div class="fragment"><pre class="fragment">namedFn().id(3).val(2).run();
</pre></div><p>The trick is obvious, each "named parameter" changes one component of the underlying class, then gives back a reference to it. Finally, <code>run()</code> executes the algorithm itself.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Although it is a class, namedFn is used pretty much like as it were a function. That it why we called it namedFn instead of <code>NamedFn</code>.</dd>
<dd>
In fact, the final <code>.run()</code> could be made unnecessary, because the algorithm could also be implemented in the destructor of <code>namedFn</code> instead. This however would make it impossible to implement functions with return values, and would also cause serious problems when implementing <a class="el" href="a00006.html#named-templ-func-param">named template parameters</a>. <b>Therefore, by convention, <code>.run()</code> must be used explicitly to execute a function having named parameters everywhere in LEMON.</b></dd></dl>
<h2><a class="anchor" id="named-templ-func-param"></a>
Named Function Template Parameters</h2>
<p>A named parameter can also be a template function. The usage is exactly the same, but the implementation behind is a kind of black magic and they are the dirtiest part of the LEMON code.</p>
<p>You will probably never need to know how it works, but if you really committed, have a look at <a class="el" href="a00450.html">lemon/graph_to_eps.h</a> for an example.</p>
<h2><a class="anchor" id="traits-classes"></a>
Traits Classes</h2>
<p>A similar game can also be played when defining classes. In this case the type of the class attributes can be changed. Initially we have to define a special class called <em>Traits Class</em> defining the default type of the attributes. Then the types of these attributes can be changed in the same way as described in the next section.</p>
<p>See <a class="el" href="a00112.html">lemon::DijkstraDefaultTraits</a> for an example how a traits class implementation looks like.</p>
<h2><a class="anchor" id="named-templ-param"></a>
Named Class Template Parameters</h2>
<p>If we would like to change the type of an attribute in a class that was instantiated by using a traits class as a template parameter, and the class contains named parameters, we do not have to instantiate again the class with new traits class, but instead adaptor classes can be used as shown in the following example.</p>
<div class="fragment"><pre class="fragment">Dijkstra&lt;&gt;::SetPredMap&lt;NullMap&lt;Node,Arc&gt; &gt;::Create
</pre></div><p>It can also be used in conjunction with other named template parameters in arbitrary order.</p>
<div class="fragment"><pre class="fragment">Dijkstra&lt;&gt;::SetDistMap&lt;MyMap&gt;::SetPredMap&lt;NullMap&lt;Node,Arc&gt; &gt;::Create
</pre></div><p>The result will be an instantiated Dijkstra class, in which the DistMap and the PredMap is modified. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
