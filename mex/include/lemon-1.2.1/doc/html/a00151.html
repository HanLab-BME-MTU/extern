<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LEMON: GomoryHu&lt; GR, CAP &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a00496.html">lemon</a>      </li>
      <li><a class="el" href="a00151.html">GomoryHu&lt; GR, CAP &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>GomoryHu&lt; GR, CAP &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00535.html">Minimum Cut Algorithms</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="lemon::GomoryHu" --><hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename GR, typename CAP&gt;<br/>
 class lemon::GomoryHu&lt; GR, CAP &gt;</h3>

<p>The Gomory-Hu tree is a tree on the node set of a given graph, but it may contain edges which are not in the original graph. It has the property that the minimum capacity edge of the path between two nodes in this tree has the same weight as the minimum cut in the graph between these nodes. Moreover the components obtained by removing this edge from the tree determine the corresponding minimum cut. Therefore once this tree is computed, the minimum cut between any pair of nodes can easily be obtained.</p>
<p>The algorithm calculates <em>n-1</em> distinct minimum cuts (currently with the <a class="el" href="a00261.html">Preflow</a> algorithm), thus it has <img class="formulaInl" alt="$O(n^3\sqrt{e})$" src="form_70.png"/> overall time complexity. It calculates a rooted Gomory-Hu tree. The structure of the tree and the edge weights can be obtained using <code><a class="el" href="a00151.html#a8a047e2d12d7f33ced19c7f71b39278e" title="Return the predecessor node in the Gomory-Hu tree.">predNode()</a></code>, <code><a class="el" href="a00151.html#a67bb03ba4623543e6b08a2f339c1080e" title="Return the weight of the predecessor edge in the Gomory-Hu tree.">predValue()</a></code> and <code><a class="el" href="a00151.html#a1723a3299a8a799b1b038ffc6a7a0d4b" title="Return the distance from the root node in the Gomory-Hu tree.">rootDist()</a></code>. The functions <code><a class="el" href="a00151.html#a1448a0251ea3eef21c4afbf5a1033c95" title="Return the minimum cut between two nodes.">minCutMap()</a></code> and <code><a class="el" href="a00151.html#ab6912debf06e1db6c9c267a93368af51" title="Return the minimum cut value between two nodes.">minCutValue()</a></code> calculate the minimum cut and the minimum cut value between any two nodes in the graph. You can also list (iterate on) the nodes and the edges of the cuts using <code><a class="el" href="a00225.html" title="Iterate on the nodes of a minimum cut.">MinCutNodeIt</a></code> and <code><a class="el" href="a00224.html" title="Iterate on the edges of a minimum cut.">MinCutEdgeIt</a></code>.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>GR</em>&nbsp;</td><td>The type of the undirected graph the algorithm runs on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CAP</em>&nbsp;</td><td>The type of the edge map containing the capacities. The default map type is <a class="el" href="a00124.html">GR::EdgeMap&lt;int&gt;</a>. </td></tr>
  </table>
  </dd>
</dl>

<p><code>#include &lt;lemon/gomory_hu.h&gt;</code></p>

<p><a href="a00742.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html">MinCutEdgeIt</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate on the edges of a minimum cut.  <a href="a00224.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html">MinCutNodeIt</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate on the nodes of a minimum cut.  <a href="a00225.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a51ae337b207f01f1c904f5eb2aa98a"></a><!-- doxytag: member="lemon::GomoryHu::Graph" ref="a2a51ae337b207f01f1c904f5eb2aa98a" args="" -->
typedef GR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html#a2a51ae337b207f01f1c904f5eb2aa98a">Graph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The graph type of the algorithm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a772fe38595302c3bf6c4e79765a37a28"></a><!-- doxytag: member="lemon::GomoryHu::Capacity" ref="a772fe38595302c3bf6c4e79765a37a28" args="" -->
typedef CAP&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html#a772fe38595302c3bf6c4e79765a37a28">Capacity</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The capacity map type of the algorithm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a316b6a8145c12ea1dbb1e1e36005a500"></a><!-- doxytag: member="lemon::GomoryHu::Value" ref="a316b6a8145c12ea1dbb1e1e36005a500" args="" -->
typedef Capacity::Value&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html#a316b6a8145c12ea1dbb1e1e36005a500">Value</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The value type of capacities. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html#a31ffa12460cb7ae041f29f09fcd9b8f4">GomoryHu</a> (const <a class="el" href="a00151.html#a2a51ae337b207f01f1c904f5eb2aa98a">Graph</a> &amp;graph, const <a class="el" href="a00151.html#a772fe38595302c3bf6c4e79765a37a28">Capacity</a> &amp;capacity)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a31ffa12460cb7ae041f29f09fcd9b8f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html#abb081203500b7357f28747e675cfd341">~GomoryHu</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution Control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd80b908dd00a6c6f28e1b1ee2d5fd269"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html#a13a43e6d814de94978c515cb084873b1">run</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run the Gomory-Hu algorithm.  <a href="#a13a43e6d814de94978c515cb084873b1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9842fe246fad3ca12bcafafc2b70d75"></a> The results of the algorithm can be obtained using these functions.<br/>
 <a class="el" href="a00151.html#a13a43e6d814de94978c515cb084873b1">run()</a> should be called before using them.<br/>
 See also <a class="el" href="a00225.html">MinCutNodeIt</a> and <a class="el" href="a00224.html">MinCutEdgeIt</a>. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Node&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html#a8a047e2d12d7f33ced19c7f71b39278e">predNode</a> (const Node &amp;node) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the predecessor node in the Gomory-Hu tree.  <a href="#a8a047e2d12d7f33ced19c7f71b39278e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00151.html#a316b6a8145c12ea1dbb1e1e36005a500">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html#a67bb03ba4623543e6b08a2f339c1080e">predValue</a> (const Node &amp;node) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the weight of the predecessor edge in the Gomory-Hu tree.  <a href="#a67bb03ba4623543e6b08a2f339c1080e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html#a1723a3299a8a799b1b038ffc6a7a0d4b">rootDist</a> (const Node &amp;node) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the distance from the root node in the Gomory-Hu tree.  <a href="#a1723a3299a8a799b1b038ffc6a7a0d4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00151.html#a316b6a8145c12ea1dbb1e1e36005a500">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html#ab6912debf06e1db6c9c267a93368af51">minCutValue</a> (const Node &amp;s, const Node &amp;t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the minimum cut value between two nodes.  <a href="#ab6912debf06e1db6c9c267a93368af51"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CutMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00151.html#a316b6a8145c12ea1dbb1e1e36005a500">Value</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00151.html#a1448a0251ea3eef21c4afbf5a1033c95">minCutMap</a> (const Node &amp;s, const Node &amp;t, CutMap &amp;cutMap) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the minimum cut between two nodes.  <a href="#a1448a0251ea3eef21c4afbf5a1033c95"></a><br/></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a31ffa12460cb7ae041f29f09fcd9b8f4"></a><!-- doxytag: member="lemon::GomoryHu::GomoryHu" ref="a31ffa12460cb7ae041f29f09fcd9b8f4" args="(const Graph &amp;graph, const Capacity &amp;capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00151.html">GomoryHu</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00151.html#a2a51ae337b207f01f1c904f5eb2aa98a">Graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00151.html#a772fe38595302c3bf6c4e79765a37a28">Capacity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>capacity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The undirected graph the algorithm runs on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>capacity</em>&nbsp;</td><td>The edge capacity map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb081203500b7357f28747e675cfd341"></a><!-- doxytag: member="lemon::GomoryHu::~GomoryHu" ref="abb081203500b7357f28747e675cfd341" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="a00151.html">GomoryHu</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a13a43e6d814de94978c515cb084873b1"></a><!-- doxytag: member="lemon::GomoryHu::run" ref="a13a43e6d814de94978c515cb084873b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function runs the Gomory-Hu algorithm. </p>

</div>
</div>
<a class="anchor" id="a8a047e2d12d7f33ced19c7f71b39278e"></a><!-- doxytag: member="lemon::GomoryHu::predNode" ref="a8a047e2d12d7f33ced19c7f71b39278e" args="(const Node &amp;node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node predNode </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the predecessor node of the given node in the Gomory-Hu tree. If <code>node</code> is the root of the tree, then it returns <code>INVALID</code>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00151.html#a13a43e6d814de94978c515cb084873b1">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a67bb03ba4623543e6b08a2f339c1080e"></a><!-- doxytag: member="lemon::GomoryHu::predValue" ref="a67bb03ba4623543e6b08a2f339c1080e" args="(const Node &amp;node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00151.html#a316b6a8145c12ea1dbb1e1e36005a500">Value</a> predValue </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the weight of the predecessor edge of the given node in the Gomory-Hu tree. If <code>node</code> is the root of the tree, the result is undefined.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00151.html#a13a43e6d814de94978c515cb084873b1">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a1723a3299a8a799b1b038ffc6a7a0d4b"></a><!-- doxytag: member="lemon::GomoryHu::rootDist" ref="a1723a3299a8a799b1b038ffc6a7a0d4b" args="(const Node &amp;node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rootDist </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the distance of the given node from the root node in the Gomory-Hu tree.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00151.html#a13a43e6d814de94978c515cb084873b1">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6912debf06e1db6c9c267a93368af51"></a><!-- doxytag: member="lemon::GomoryHu::minCutValue" ref="ab6912debf06e1db6c9c267a93368af51" args="(const Node &amp;s, const Node &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00151.html#a316b6a8145c12ea1dbb1e1e36005a500">Value</a> minCutValue </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the minimum cut value between the nodes <code>s</code> and <code>t</code>. It finds the nearest common ancestor of the given nodes in the Gomory-Hu tree and calculates the minimum weight edge on the paths to the ancestor.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00151.html#a13a43e6d814de94978c515cb084873b1">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a1448a0251ea3eef21c4afbf5a1033c95"></a><!-- doxytag: member="lemon::GomoryHu::minCutMap" ref="a1448a0251ea3eef21c4afbf5a1033c95" args="(const Node &amp;s, const Node &amp;t, CutMap &amp;cutMap) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00151.html#a316b6a8145c12ea1dbb1e1e36005a500">Value</a> minCutMap </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CutMap &amp;&nbsp;</td>
          <td class="paramname"> <em>cutMap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the minimum cut between the nodes <code>s</code> and <code>t</code> in the <code>cutMap</code> parameter by setting the nodes in the component of <code>s</code> to <code>true</code> and the other nodes to <code>false</code>.</p>
<p>For higher level interfaces see <a class="el" href="a00225.html" title="Iterate on the nodes of a minimum cut.">MinCutNodeIt</a> and <a class="el" href="a00224.html" title="Iterate on the edges of a minimum cut.">MinCutEdgeIt</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The base node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The node you want to separate from node <code>s</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cutMap</em>&nbsp;</td><td>The cut will be returned in this map. It must be a <code>bool</code> (or convertible) <a class="el" href="a00270.html">ReadWriteMap</a> on the graph nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the minimum cut between <code>s</code> and <code>t</code>.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00151.html#a13a43e6d814de94978c515cb084873b1">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
