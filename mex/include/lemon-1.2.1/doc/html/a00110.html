<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LEMON: Dijkstra&lt; GR, LEN, TR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a00496.html">lemon</a>      </li>
      <li><a class="el" href="a00110.html">Dijkstra&lt; GR, LEN, TR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>Dijkstra&lt; GR, LEN, TR &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00531.html">Shortest Path Algorithms</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="lemon::Dijkstra" --><hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename GR, typename LEN, typename TR&gt;<br/>
 class lemon::Dijkstra&lt; GR, LEN, TR &gt;</h3>

<p>This class provides an efficient implementation of the Dijkstra algorithm.</p>
<p>The Dijkstra algorithm solves the single-source shortest path problem when all arc lengths are non-negative. If there are negative lengths, the <a class="el" href="a00034.html" title="BellmanFord algorithm class.">BellmanFord</a> algorithm should be used instead.</p>
<p>The arc lengths are passed to the algorithm using a <a class="el" href="a00269.html">ReadMap</a>, so it is easy to change it to any kind of length. The type of the length is determined by the <a class="el" href="a00269.html#a34b57a974fe67a997b7693e6e71cd904">Value</a> of the length map. It is also possible to change the underlying priority heap.</p>
<p>There is also a <a class="el" href="a00531.html#ga6aa57523fe00e2b8fe2f5cd17dd15cea">function-type interface</a> for the Dijkstra algorithm, which is convenient in the simplier cases and it can be used easier.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>GR</em>&nbsp;</td><td>The type of the digraph the algorithm runs on. The default type is <a class="el" href="a00203.html">ListDigraph</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LEN</em>&nbsp;</td><td>A <a class="el" href="a00269.html">readable</a> arc map that specifies the lengths of the arcs. It is read once for each arc, so the map may involve in relatively time consuming process to compute the arc lengths if it is necessary. The default map type is <a class="el" href="a00026.html">GR::ArcMap&lt;int&gt;</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TR</em>&nbsp;</td><td>The traits class that defines various types used by the algorithm. By default, it is <a class="el" href="a00112.html">DijkstraDefaultTraits&lt;GR, LEN&gt;</a>. In most cases, this parameter should not be set directly, consider to use the named template parameters instead. </td></tr>
  </table>
  </dd>
</dl>

<p><code>#include &lt;lemon/dijkstra.h&gt;</code></p>

<p><a href="a00688.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html">SetDistMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting <code>DistMap</code> type.  <a href="a00290.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00299.html">SetHeap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting heap and cross reference types  <a href="a00299.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00306.html">SetOperationTraits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting <code>OperationTraits</code> type  <a href="a00306.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html">SetPredMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting <code>PredMap</code> type.  <a href="a00314.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00319.html">SetProcessedMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting <code>ProcessedMap</code> type.  <a href="a00319.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00327.html">SetStandardHeap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting heap and cross reference types with automatic allocation  <a href="a00327.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00330.html">SetStandardProcessedMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting <code>ProcessedMap</code> type to be <code>Digraph::NodeMap&lt;bool&gt;</code>.  <a href="a00330.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a750f38b47fd56ef715849c3bd77fbe77"></a><!-- doxytag: member="lemon::Dijkstra::Digraph" ref="a750f38b47fd56ef715849c3bd77fbe77" args="" -->
typedef TR::Digraph&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the digraph the algorithm runs on. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2042899ede28a8f6f0fdceb92a7d3c2"></a><!-- doxytag: member="lemon::Dijkstra::Value" ref="aa2042899ede28a8f6f0fdceb92a7d3c2" args="" -->
typedef TR::Value&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the arc lengths. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1094a242a4e9be216f0623b0a7381c0"></a><!-- doxytag: member="lemon::Dijkstra::LengthMap" ref="ac1094a242a4e9be216f0623b0a7381c0" args="" -->
typedef TR::LengthMap&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#ac1094a242a4e9be216f0623b0a7381c0">LengthMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the map that stores the arc lengths. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc9638061e7acac70160feb0ea49c29c"></a><!-- doxytag: member="lemon::Dijkstra::PredMap" ref="adc9638061e7acac70160feb0ea49c29c" args="" -->
typedef TR::PredMap&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the map that stores the predecessor arcs of the shortest paths. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6d9c2819f215994ded26fbe42e2fd26"></a><!-- doxytag: member="lemon::Dijkstra::DistMap" ref="ad6d9c2819f215994ded26fbe42e2fd26" args="" -->
typedef TR::DistMap&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#ad6d9c2819f215994ded26fbe42e2fd26">DistMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the map that stores the distances of the nodes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43e332c55acc2c5cb99d35ff40accab1"></a><!-- doxytag: member="lemon::Dijkstra::ProcessedMap" ref="a43e332c55acc2c5cb99d35ff40accab1" args="" -->
typedef TR::ProcessedMap&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a43e332c55acc2c5cb99d35ff40accab1">ProcessedMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the map that indicates which nodes are processed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d7ae5a0651af9c9cfadd1462718979d"></a><!-- doxytag: member="lemon::Dijkstra::Path" ref="a4d7ae5a0651af9c9cfadd1462718979d" args="" -->
typedef PredMapPath&lt; <a class="el" href="a00110.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a>, <br class="typebreak"/>
<a class="el" href="a00110.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a4d7ae5a0651af9c9cfadd1462718979d">Path</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the paths. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dc498f33875179555a71ba9441c400a"></a><!-- doxytag: member="lemon::Dijkstra::HeapCrossRef" ref="a0dc498f33875179555a71ba9441c400a" args="" -->
typedef TR::HeapCrossRef&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a0dc498f33875179555a71ba9441c400a">HeapCrossRef</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The cross reference type used for the current heap. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1e3f1c47cd4bffb15e3bbc452585f7c"></a><!-- doxytag: member="lemon::Dijkstra::Heap" ref="ab1e3f1c47cd4bffb15e3bbc452585f7c" args="" -->
typedef TR::Heap&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#ab1e3f1c47cd4bffb15e3bbc452585f7c">Heap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The heap type used by the algorithm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afda95bfb086e37f03cb0be4ba8725f47"></a><!-- doxytag: member="lemon::Dijkstra::OperationTraits" ref="afda95bfb086e37f03cb0be4ba8725f47" args="" -->
typedef TR::OperationTraits&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#afda95bfb086e37f03cb0be4ba8725f47">OperationTraits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00111.html">operation traits class</a> of the algorithm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab157e5452122f7a7f73dfda5ed931d69"></a><!-- doxytag: member="lemon::Dijkstra::Traits" ref="ab157e5452122f7a7f73dfda5ed931d69" args="" -->
typedef TR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#ab157e5452122f7a7f73dfda5ed931d69">Traits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00112.html">traits class</a> of the algorithm. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a58fc0895a271a1aa712f66aaf3425b12">Dijkstra</a> (const <a class="el" href="a00110.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a> &amp;g, const <a class="el" href="a00110.html#ac1094a242a4e9be216f0623b0a7381c0">LengthMap</a> &amp;length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a58fc0895a271a1aa712f66aaf3425b12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f2cad16e6cb57cad22fe766c9e809ca"></a><!-- doxytag: member="lemon::Dijkstra::~Dijkstra" ref="a9f2cad16e6cb57cad22fe766c9e809ca" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a9f2cad16e6cb57cad22fe766c9e809ca">~Dijkstra</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00110.html">Dijkstra</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#acca1fc5a2484f8284b37ac8b98a6de89">lengthMap</a> (const <a class="el" href="a00110.html#ac1094a242a4e9be216f0623b0a7381c0">LengthMap</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the length map.  <a href="#acca1fc5a2484f8284b37ac8b98a6de89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00110.html">Dijkstra</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a553990801b3f933961ad14abfee00c0e">predMap</a> (<a class="el" href="a00110.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the map that stores the predecessor arcs.  <a href="#a553990801b3f933961ad14abfee00c0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00110.html">Dijkstra</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a6f543d7d3c4b2ab9ecdef5d14f90269d">processedMap</a> (<a class="el" href="a00110.html#a43e332c55acc2c5cb99d35ff40accab1">ProcessedMap</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the map that indicates which nodes are processed.  <a href="#a6f543d7d3c4b2ab9ecdef5d14f90269d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00110.html">Dijkstra</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a344715cda707dac050bf32c85923f651">distMap</a> (<a class="el" href="a00110.html#ad6d9c2819f215994ded26fbe42e2fd26">DistMap</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the map that stores the distances of the nodes.  <a href="#a344715cda707dac050bf32c85923f651"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00110.html">Dijkstra</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a7a0403be9c030237c46a9ab320f5bfbe">heap</a> (<a class="el" href="a00110.html#ab1e3f1c47cd4bffb15e3bbc452585f7c">Heap</a> &amp;hp, <a class="el" href="a00110.html#a0dc498f33875179555a71ba9441c400a">HeapCrossRef</a> &amp;cr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the heap and the cross reference used by algorithm.  <a href="#a7a0403be9c030237c46a9ab320f5bfbe"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution Control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd80b908dd00a6c6f28e1b1ee2d5fd269"></a> The simplest way to execute the Dijkstra algorithm is to use one of the member functions called <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a>.<br/>
 If you need better control on the execution, you have to call <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> first, then you can add several source nodes with <a class="el" href="a00110.html#acf3cbe74733e4534c1cebb8383974bae">addSource()</a>. Finally the actual path computation can be performed with one of the <a class="el" href="a00110.html#a60de64d75454385b23995437f1d72669">start()</a> functions. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#acf3cbe74733e4534c1cebb8383974bae">addSource</a> (Node s, <a class="el" href="a00110.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> dst=OperationTraits::zero())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a new source node.  <a href="#acf3cbe74733e4534c1cebb8383974bae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Node&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#adba758047d7378b8a06320d29ce170d7">processNextNode</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes the next node in the priority heap.  <a href="#adba758047d7378b8a06320d29ce170d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Node&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#aca98e3b1fef1a4508df143a24b73b046">nextNode</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The next node to be processed.  <a href="#aca98e3b1fef1a4508df143a24b73b046"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#ab6dcd2be02feaff0a95c21824e805445">emptyQueue</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>false</code> if there are nodes to be processed.  <a href="#ab6dcd2be02feaff0a95c21824e805445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a942d30059e28f60ba6dd1944ab8e416e">queueSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of the nodes to be processed.  <a href="#a942d30059e28f60ba6dd1944ab8e416e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a60de64d75454385b23995437f1d72669">start</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the algorithm.  <a href="#a60de64d75454385b23995437f1d72669"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a8b8de9dfc16e4b3cb6b38733e82f6449">start</a> (Node t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the algorithm until the given target node is processed.  <a href="#a8b8de9dfc16e4b3cb6b38733e82f6449"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NodeBoolMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Node&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00110.html#a4d3d39ff1805757f57570e6db83630cc">start</a> (const NodeBoolMap &amp;nm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the algorithm until a condition is met.  <a href="#a4d3d39ff1805757f57570e6db83630cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run</a> (Node s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runs the algorithm from the given source node.  <a href="#ae3f0682c90a4e8a23c259943e899402e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#ad2c3c4217c98b58a8618397d65d400c8">run</a> (Node s, Node t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the shortest path between <code>s</code> and <code>t</code>.  <a href="#ad2c3c4217c98b58a8618397d65d400c8"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9842fe246fad3ca12bcafafc2b70d75"></a> The results of the Dijkstra algorithm can be obtained using these functions.<br/>
 Either <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> should be called before using them. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00110.html#a4d7ae5a0651af9c9cfadd1462718979d">Path</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a6a33507c667ac2bddd240d0baff1a573">path</a> (Node t) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The shortest path to the given node.  <a href="#a6a33507c667ac2bddd240d0baff1a573"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00110.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a70a41051a602b0a9134d128cf1f409f6">dist</a> (Node v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The distance of the given node from the root(s).  <a href="#a70a41051a602b0a9134d128cf1f409f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Arc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#af9fdbb84b58bd3f5daedde027070e056">predArc</a> (Node v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the 'previous arc' of the shortest path tree for the given node.  <a href="#af9fdbb84b58bd3f5daedde027070e056"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Node&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a89bd1c535e3d4fcb9c58afbb54ac47e1">predNode</a> (Node v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the 'previous node' of the shortest path tree for the given node.  <a href="#a89bd1c535e3d4fcb9c58afbb54ac47e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00110.html#ad6d9c2819f215994ded26fbe42e2fd26">DistMap</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a77feee7321863f24b67813c0ef8dc5c0">distMap</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const reference to the node map that stores the distances of the nodes.  <a href="#a77feee7321863f24b67813c0ef8dc5c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00110.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#aeec5920cc073b88c4c5f6c46a8f4aa4b">predMap</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const reference to the node map that stores the predecessor arcs.  <a href="#aeec5920cc073b88c4c5f6c46a8f4aa4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#abb98c427556a2afe917e41fe8d3e75bf">reached</a> (Node v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the given node is reached from the root(s).  <a href="#abb98c427556a2afe917e41fe8d3e75bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a376f9f86c0b6bf5fbcf5ee8d76f4cc7a">processed</a> (Node v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a node is processed.  <a href="#a376f9f86c0b6bf5fbcf5ee8d76f4cc7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00110.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html#a514b1faa39e460ebc8e00c90d839f3cf">currentDist</a> (Node v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current distance of the given node from the root(s).  <a href="#a514b1faa39e460ebc8e00c90d839f3cf"></a><br/></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a58fc0895a271a1aa712f66aaf3425b12"></a><!-- doxytag: member="lemon::Dijkstra::Dijkstra" ref="a58fc0895a271a1aa712f66aaf3425b12" args="(const Digraph &amp;g, const LengthMap &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00110.html">Dijkstra</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00110.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00110.html#ac1094a242a4e9be216f0623b0a7381c0">LengthMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>The digraph the algorithm runs on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length map used by the algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acca1fc5a2484f8284b37ac8b98a6de89"></a><!-- doxytag: member="lemon::Dijkstra::lengthMap" ref="acca1fc5a2484f8284b37ac8b98a6de89" args="(const LengthMap &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00110.html">Dijkstra</a>&amp; lengthMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00110.html#ac1094a242a4e9be216f0623b0a7381c0">LengthMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the length map. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a553990801b3f933961ad14abfee00c0e"></a><!-- doxytag: member="lemon::Dijkstra::predMap" ref="a553990801b3f933961ad14abfee00c0e" args="(PredMap &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00110.html">Dijkstra</a>&amp; predMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00110.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the map that stores the predecessor arcs. If you don't use this function before calling <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, an instance will be allocated automatically. The destructor deallocates this automatically allocated map, of course. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a6f543d7d3c4b2ab9ecdef5d14f90269d"></a><!-- doxytag: member="lemon::Dijkstra::processedMap" ref="a6f543d7d3c4b2ab9ecdef5d14f90269d" args="(ProcessedMap &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00110.html">Dijkstra</a>&amp; processedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00110.html#a43e332c55acc2c5cb99d35ff40accab1">ProcessedMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the map that indicates which nodes are processed. If you don't use this function before calling <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, an instance will be allocated automatically. The destructor deallocates this automatically allocated map, of course. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a344715cda707dac050bf32c85923f651"></a><!-- doxytag: member="lemon::Dijkstra::distMap" ref="a344715cda707dac050bf32c85923f651" args="(DistMap &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00110.html">Dijkstra</a>&amp; distMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00110.html#ad6d9c2819f215994ded26fbe42e2fd26">DistMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the map that stores the distances of the nodes calculated by the algorithm. If you don't use this function before calling <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, an instance will be allocated automatically. The destructor deallocates this automatically allocated map, of course. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a0403be9c030237c46a9ab320f5bfbe"></a><!-- doxytag: member="lemon::Dijkstra::heap" ref="a7a0403be9c030237c46a9ab320f5bfbe" args="(Heap &amp;hp, HeapCrossRef &amp;cr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00110.html">Dijkstra</a>&amp; heap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00110.html#ab1e3f1c47cd4bffb15e3bbc452585f7c">Heap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00110.html#a0dc498f33875179555a71ba9441c400a">HeapCrossRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the heap and the cross reference used by algorithm. If you don't use this function before calling <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, heap and cross reference instances will be allocated automatically. The destructor deallocates these automatically allocated objects, of course. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a02fd73d861ef2e4aabb38c0c9ff82947"></a><!-- doxytag: member="lemon::Dijkstra::init" ref="a02fd73d861ef2e4aabb38c0c9ff82947" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the internal data structures. </p>

</div>
</div>
<a class="anchor" id="acf3cbe74733e4534c1cebb8383974bae"></a><!-- doxytag: member="lemon::Dijkstra::addSource" ref="acf3cbe74733e4534c1cebb8383974bae" args="(Node s, Value dst=OperationTraits::zero())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addSource </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00110.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&nbsp;</td>
          <td class="paramname"> <em>dst</em> = <code>OperationTraits::zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a new source node to the priority heap. The optional second parameter is the initial distance of the node.</p>
<p>The function checks if the node has already been added to the heap and it is pushed to the heap only if either it was not in the heap or the shortest path found till then is shorter than <code>dst</code>. </p>

</div>
</div>
<a class="anchor" id="adba758047d7378b8a06320d29ce170d7"></a><!-- doxytag: member="lemon::Dijkstra::processNextNode" ref="adba758047d7378b8a06320d29ce170d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node processNextNode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Processes the next node in the priority heap.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The processed node.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The priority heap must not be empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aca98e3b1fef1a4508df143a24b73b046"></a><!-- doxytag: member="lemon::Dijkstra::nextNode" ref="aca98e3b1fef1a4508df143a24b73b046" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node nextNode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the next node to be processed or <code>INVALID</code> if the priority heap is empty. </p>

</div>
</div>
<a class="anchor" id="ab6dcd2be02feaff0a95c21824e805445"></a><!-- doxytag: member="lemon::Dijkstra::emptyQueue" ref="ab6dcd2be02feaff0a95c21824e805445" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool emptyQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>false</code> if there are nodes to be processed in the priority heap. </p>

</div>
</div>
<a class="anchor" id="a942d30059e28f60ba6dd1944ab8e416e"></a><!-- doxytag: member="lemon::Dijkstra::queueSize" ref="a942d30059e28f60ba6dd1944ab8e416e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queueSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of the nodes to be processed in the priority heap. </p>

</div>
</div>
<a class="anchor" id="a60de64d75454385b23995437f1d72669"></a><!-- doxytag: member="lemon::Dijkstra::start" ref="a60de64d75454385b23995437f1d72669" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes the algorithm.</p>
<p>This method runs the Dijkstra algorithm from the root node(s) in order to compute the shortest path to each node.</p>
<p>The algorithm computes</p>
<ul>
<li>the shortest path tree (forest),</li>
<li>the distance of each node from the root(s).</li>
</ul>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called and at least one root node should be added with <a class="el" href="a00110.html#acf3cbe74733e4534c1cebb8383974bae" title="Adds a new source node.">addSource()</a> before using this function.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><code>d.start()</code> is just a shortcut of the following code. <div class="fragment"><pre class="fragment">         <span class="keywordflow">while</span> ( !d.emptyQueue() ) {
           d.processNextNode();
         }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8de9dfc16e4b3cb6b38733e82f6449"></a><!-- doxytag: member="lemon::Dijkstra::start" ref="a8b8de9dfc16e4b3cb6b38733e82f6449" args="(Node t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes the algorithm until the given target node is processed.</p>
<p>This method runs the Dijkstra algorithm from the root node(s) in order to compute the shortest path to <code>t</code>.</p>
<p>The algorithm computes</p>
<ul>
<li>the shortest path to <code>t</code>,</li>
<li>the distance of <code>t</code> from the root(s).</li>
</ul>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called and at least one root node should be added with <a class="el" href="a00110.html#acf3cbe74733e4534c1cebb8383974bae" title="Adds a new source node.">addSource()</a> before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d3d39ff1805757f57570e6db83630cc"></a><!-- doxytag: member="lemon::Dijkstra::start" ref="a4d3d39ff1805757f57570e6db83630cc" args="(const NodeBoolMap &amp;nm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node start </td>
          <td>(</td>
          <td class="paramtype">const NodeBoolMap &amp;&nbsp;</td>
          <td class="paramname"> <em>nm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes the algorithm until a condition is met.</p>
<p>This method runs the Dijkstra algorithm from the root node(s) in order to compute the shortest path to a node <code>v</code> with <code>nm[v]</code> true, if such a node can be found.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nm</em>&nbsp;</td><td>A <code>bool</code> (or convertible) node map. The algorithm will stop when it reaches a node <code>v</code> with <code>nm[v]</code> true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The reached node <code>v</code> with <code>nm[v]</code> true or <code>INVALID</code> if no such node was found.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called and at least one root node should be added with <a class="el" href="a00110.html#acf3cbe74733e4534c1cebb8383974bae" title="Adds a new source node.">addSource()</a> before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3f0682c90a4e8a23c259943e899402e"></a><!-- doxytag: member="lemon::Dijkstra::run" ref="ae3f0682c90a4e8a23c259943e899402e" args="(Node s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method runs the Dijkstra algorithm from node <code>s</code> in order to compute the shortest path to each node.</p>
<p>The algorithm computes</p>
<ul>
<li>the shortest path tree,</li>
<li>the distance of each node from the root.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd><code>d.run(s)</code> is just a shortcut of the following code. <div class="fragment"><pre class="fragment">         d.init();
         d.addSource(s);
         d.start();
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2c3c4217c98b58a8618397d65d400c8"></a><!-- doxytag: member="lemon::Dijkstra::run" ref="ad2c3c4217c98b58a8618397d65d400c8" args="(Node s, Node t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool run </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method runs the Dijkstra algorithm from node <code>s</code> in order to compute the shortest path to node <code>t</code> (it stops searching when <code>t</code> is processed).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <code>t</code> is reachable form <code>s</code>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Apart from the return value, <code>d.run(s,t)</code> is just a shortcut of the following code. <div class="fragment"><pre class="fragment">         d.init();
         d.addSource(s);
         d.start(t);
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a33507c667ac2bddd240d0baff1a573"></a><!-- doxytag: member="lemon::Dijkstra::path" ref="a6a33507c667ac2bddd240d0baff1a573" args="(Node t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00110.html#a4d7ae5a0651af9c9cfadd1462718979d">Path</a> path </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the shortest path to the given node from the root(s).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd><code>t</code> should be reached from the root(s).</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a70a41051a602b0a9134d128cf1f409f6"></a><!-- doxytag: member="lemon::Dijkstra::dist" ref="a70a41051a602b0a9134d128cf1f409f6" args="(Node v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00110.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> dist </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the distance of the given node from the root(s).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If node <code>v</code> is not reached from the root(s), then the return value of this function is undefined.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="af9fdbb84b58bd3f5daedde027070e056"></a><!-- doxytag: member="lemon::Dijkstra::predArc" ref="af9fdbb84b58bd3f5daedde027070e056" args="(Node v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Arc predArc </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the 'previous arc' of the shortest path tree for the node <code>v</code>, i.e. it returns the last arc of a shortest path from a root to <code>v</code>. It is <code>INVALID</code> if <code>v</code> is not reached from the root(s) or if <code>v</code> is a root.</p>
<p>The shortest path tree used here is equal to the shortest path tree used in <a class="el" href="a00110.html#a89bd1c535e3d4fcb9c58afbb54ac47e1">predNode()</a> and <a class="el" href="a00110.html#a553990801b3f933961ad14abfee00c0e">predMap()</a>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a89bd1c535e3d4fcb9c58afbb54ac47e1"></a><!-- doxytag: member="lemon::Dijkstra::predNode" ref="a89bd1c535e3d4fcb9c58afbb54ac47e1" args="(Node v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node predNode </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the 'previous node' of the shortest path tree for the node <code>v</code>, i.e. it returns the last but one node of a shortest path from a root to <code>v</code>. It is <code>INVALID</code> if <code>v</code> is not reached from the root(s) or if <code>v</code> is a root.</p>
<p>The shortest path tree used here is equal to the shortest path tree used in <a class="el" href="a00110.html#af9fdbb84b58bd3f5daedde027070e056">predArc()</a> and <a class="el" href="a00110.html#a553990801b3f933961ad14abfee00c0e">predMap()</a>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a77feee7321863f24b67813c0ef8dc5c0"></a><!-- doxytag: member="lemon::Dijkstra::distMap" ref="a77feee7321863f24b67813c0ef8dc5c0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00110.html#ad6d9c2819f215994ded26fbe42e2fd26">DistMap</a>&amp; distMap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a const reference to the node map that stores the distances of the nodes calculated by the algorithm.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="aeec5920cc073b88c4c5f6c46a8f4aa4b"></a><!-- doxytag: member="lemon::Dijkstra::predMap" ref="aeec5920cc073b88c4c5f6c46a8f4aa4b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00110.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a>&amp; predMap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a const reference to the node map that stores the predecessor arcs, which form the shortest path tree (forest).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="abb98c427556a2afe917e41fe8d3e75bf"></a><!-- doxytag: member="lemon::Dijkstra::reached" ref="abb98c427556a2afe917e41fe8d3e75bf" args="(Node v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reached </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>true</code> if <code>v</code> is reached from the root(s).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a376f9f86c0b6bf5fbcf5ee8d76f4cc7a"></a><!-- doxytag: member="lemon::Dijkstra::processed" ref="a376f9f86c0b6bf5fbcf5ee8d76f4cc7a" args="(Node v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool processed </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>true</code> if <code>v</code> is processed, i.e. the shortest path to <code>v</code> has already found.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a514b1faa39e460ebc8e00c90d839f3cf"></a><!-- doxytag: member="lemon::Dijkstra::currentDist" ref="a514b1faa39e460ebc8e00c90d839f3cf" args="(Node v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00110.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> currentDist </td>
          <td>(</td>
          <td class="paramtype">Node&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the current distance of the given node from the root(s). It may be decreased in the following processes.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00110.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00110.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function and node <code>v</code> must be reached but not necessarily processed. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
