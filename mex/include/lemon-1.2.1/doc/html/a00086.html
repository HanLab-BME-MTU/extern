<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LEMON: CostScaling&lt; GR, V, C, TR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a00496.html">lemon</a>      </li>
      <li><a class="el" href="a00086.html">CostScaling&lt; GR, V, C, TR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<h1>CostScaling&lt; GR, V, C, TR &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00534.html">Minimum Cost Flow Algorithms</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="lemon::CostScaling" --><hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename GR, typename V, typename C, typename TR&gt;<br/>
 class lemon::CostScaling&lt; GR, V, C, TR &gt;</h3>

<p><a class="el" href="a00086.html">CostScaling</a> implements a cost scaling algorithm that performs push/augment and relabel operations for finding a <a class="el" href="a00005.html">minimum cost flow</a> <a class="el" href="a00007.html#amo93networkflows">[AMO93]</a>, <a class="el" href="a00007.html#goldberg90approximation">[GT90]</a>, <a class="el" href="a00007.html#goldberg97efficient">[Gol97]</a>, <a class="el" href="a00007.html#bunnagel98efficient">[BKV98]</a>. It is a highly efficient primal-dual solution method, which can be viewed as the generalization of the <a class="el" href="a00261.html">preflow push-relabel</a> algorithm for the maximum flow problem.</p>
<p>Most of the parameters of the problem (except for the digraph) can be given using separate functions, and the algorithm can be executed using the <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> function. If some parameters are not specified, then default values will be used.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>GR</em>&nbsp;</td><td>The digraph type the algorithm runs on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>The number type used for flow amounts, capacity bounds and supply values in the algorithm. By default, it is <code>int</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>The number type used for costs and potentials in the algorithm. By default, it is the same as <code>V</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TR</em>&nbsp;</td><td>The traits class that defines various types used by the algorithm. By default, it is <a class="el" href="a00087.html">CostScalingDefaultTraits&lt;GR, V, C&gt;</a>. In most cases, this parameter should not be set directly, consider to use the named template parameters instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Both number types must be signed and all input data must be integer. </dd>
<dd>
This algorithm does not support negative costs for such arcs that have infinite upper bound.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>CostScaling provides three different internal methods, from which the most efficient one is used by default. For more information, see <a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a>. </dd></dl>

<p><code>#include &lt;lemon/cost_scaling.h&gt;</code></p>

<p><a href="a00648.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html">SetLargeCost</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting <code>LargeCost</code> type.  <a href="a00303.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> { <a class="el" href="a00086.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483">INFEASIBLE</a>, 
<a class="el" href="a00086.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad">OPTIMAL</a>, 
<a class="el" href="a00086.html#a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef">UNBOUNDED</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Problem type constants for the <code><a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3" title="Run the algorithm.">run()</a></code> function. </p>
 <a href="a00086.html#a4c669cb1cb4d98dfea944e9ceec7d33e">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a> { <a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0fad263caec619c4d99e4684ba0fabd9493">PUSH</a>, 
<a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0facd2e1aa2398886ced14024f626167b10">AUGMENT</a>, 
<a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0fad4476e3f57a85ac799fa83de6730c665">PARTIAL_AUGMENT</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Constants for selecting the internal method. </p>
 <a href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0f">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a750f38b47fd56ef715849c3bd77fbe77"></a><!-- doxytag: member="lemon::CostScaling::Digraph" ref="a750f38b47fd56ef715849c3bd77fbe77" args="" -->
typedef TR::Digraph&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the digraph. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2042899ede28a8f6f0fdceb92a7d3c2"></a><!-- doxytag: member="lemon::CostScaling::Value" ref="aa2042899ede28a8f6f0fdceb92a7d3c2" args="" -->
typedef TR::Value&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the flow amounts, capacity bounds and supply values. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9142822eba184f2778b6aac70b0900b3"></a><!-- doxytag: member="lemon::CostScaling::Cost" ref="a9142822eba184f2778b6aac70b0900b3" args="" -->
typedef TR::Cost&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a9142822eba184f2778b6aac70b0900b3">Cost</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the arc costs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef TR::LargeCost&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a7f34159326618acfb683317c3df26662">LargeCost</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The large cost type.  <a href="#a7f34159326618acfb683317c3df26662"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab157e5452122f7a7f73dfda5ed931d69"></a><!-- doxytag: member="lemon::CostScaling::Traits" ref="ab157e5452122f7a7f73dfda5ed931d69" args="" -->
typedef TR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#ab157e5452122f7a7f73dfda5ed931d69">Traits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00087.html">traits class</a> of the algorithm. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#aef36da2d5f6a91d3c945078c91a00f29">CostScaling</a> (const GR &amp;graph)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#aef36da2d5f6a91d3c945078c91a00f29"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Parameters</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp3225a10b07f1580f10dee4abc3779e6c"></a> The parameters of the algorithm can be specified using these functions. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LowerMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00086.html">CostScaling</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00086.html#aec87dc6ef6c33e4ada265b63bc212224">lowerMap</a> (const LowerMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the lower bounds on the arcs.  <a href="#aec87dc6ef6c33e4ada265b63bc212224"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename UpperMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00086.html">CostScaling</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00086.html#a82c76205dd2bbd823ea4bde64e043599">upperMap</a> (const UpperMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the upper bounds (capacities) on the arcs.  <a href="#a82c76205dd2bbd823ea4bde64e043599"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CostMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00086.html">CostScaling</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00086.html#a541ff34efc2aef2ca5c27c2183955909">costMap</a> (const CostMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the costs of the arcs.  <a href="#a541ff34efc2aef2ca5c27c2183955909"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SupplyMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00086.html">CostScaling</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00086.html#ad8613005e2f06793a1870f0acf4f9673">supplyMap</a> (const SupplyMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the supply values of the nodes.  <a href="#ad8613005e2f06793a1870f0acf4f9673"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00086.html">CostScaling</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a606e5cc8a41acd2f6f0998c096e79a0d">stSupply</a> (const Node &amp;s, const Node &amp;t, <a class="el" href="a00086.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set single source and target nodes and a supply value.  <a href="#a606e5cc8a41acd2f6f0998c096e79a0d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpfb61d1f5bc43a30e898d23cf770546c2"></a> The algorithm can be executed using <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a>. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00086.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run</a> (<a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a> method=PARTIAL_AUGMENT, int factor=8)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run the algorithm.  <a href="#a05f1f2fac9f40760afbd2fb3af51f2b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00086.html">CostScaling</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset all the parameters that have been given before.  <a href="#a3da4b33bee24846e97c4fad32696d7b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00086.html">CostScaling</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#aec24c3696fc3c1818effd0523dffa452">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset all the parameters that have been given before.  <a href="#aec24c3696fc3c1818effd0523dffa452"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9842fe246fad3ca12bcafafc2b70d75"></a> The results of the algorithm can be obtained using these functions.<br/>
 The <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> function must be called before using them. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Number&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00086.html#a53bae6343367680cea8a37c2f6cd17b3">totalCost</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the total cost of the found flow.  <a href="#a53bae6343367680cea8a37c2f6cd17b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00086.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a7fc53c0667fdfb95dadd6a302f045941">flow</a> (const Arc &amp;a) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the flow on the given arc.  <a href="#a7fc53c0667fdfb95dadd6a302f045941"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FlowMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00086.html#a0bacd75ff1778bdc0a2c3ab0d0d00f36">flowMap</a> (FlowMap &amp;map) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the flow map (the primal solution).  <a href="#a0bacd75ff1778bdc0a2c3ab0d0d00f36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00086.html#a9142822eba184f2778b6aac70b0900b3">Cost</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#ac97efaa2b500bb002f116bf4ba7c9b0b">potential</a> (const Node &amp;n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the potential (dual value) of the given node.  <a href="#ac97efaa2b500bb002f116bf4ba7c9b0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PotentialMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00086.html#a5011146c7986300cf2a684fb7aa8419a">potentialMap</a> (PotentialMap &amp;map) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the potential map (the dual solution).  <a href="#a5011146c7986300cf2a684fb7aa8419a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00086.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a601ffd79f13610daacadd46f973507c5">INF</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant for infinite upper bounds (capacities).  <a href="#a601ffd79f13610daacadd46f973507c5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0aff70e55343af53c5263a64f6bf3c3"></a><!-- doxytag: member="lemon::CostScaling::startAugment" ref="ac0aff70e55343af53c5263a64f6bf3c3" args="(int max_length=std::numeric_limits&lt; int &gt;::max())" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#ac0aff70e55343af53c5263a64f6bf3c3">startAugment</a> (int max_length=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute the algorithm performing augment and relabel operations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d8a4c20a6226e471b185f33b68eadb1"></a><!-- doxytag: member="lemon::CostScaling::startPush" ref="a0d8a4c20a6226e471b185f33b68eadb1" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html#a0d8a4c20a6226e471b185f33b68eadb1">startPush</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute the algorithm performing push and relabel operations. <br/></td></tr>
</table>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a7f34159326618acfb683317c3df26662"></a><!-- doxytag: member="lemon::CostScaling::LargeCost" ref="a7f34159326618acfb683317c3df26662" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TR::LargeCost <a class="el" href="a00086.html#a7f34159326618acfb683317c3df26662">LargeCost</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The large cost type used for internal computations. By default, it is <code>long</code> <code>long</code> if the <code>Cost</code> type is integer, otherwise it is <code>double</code>. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33e"></a><!-- doxytag: member="lemon::CostScaling::ProblemType" ref="a4c669cb1cb4d98dfea944e9ceec7d33e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00086.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum type containing the problem type constants that can be returned by the <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> function of the algorithm. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483"></a><!-- doxytag: member="INFEASIBLE" ref="a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483" args="" -->INFEASIBLE</em>&nbsp;</td><td>
<p>The problem has no feasible solution (flow). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad"></a><!-- doxytag: member="OPTIMAL" ref="a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad" args="" -->OPTIMAL</em>&nbsp;</td><td>
<p>The problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef"></a><!-- doxytag: member="UNBOUNDED" ref="a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef" args="" -->UNBOUNDED</em>&nbsp;</td><td>
<p>The digraph contains an arc of negative cost and infinite upper bound. It means that the objective function is unbounded on that arc, however, note that it could actually be bounded over the feasible flows, but this algroithm cannot handle these cases. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a3c0067e44c5ef3210a256d06c16b0f"></a><!-- doxytag: member="lemon::CostScaling::Method" ref="a2a3c0067e44c5ef3210a256d06c16b0f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum type containing constants for selecting the internal method for the <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> function.</p>
<p><a class="el" href="a00086.html">CostScaling</a> provides three internal methods that differ mainly in their base operations, which are used in conjunction with the relabel operation. By default, the so called <a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0fad4476e3f57a85ac799fa83de6730c665">Partial Augment-Relabel</a> method is used, which proved to be the most efficient and the most robust on various test inputs. However, the other methods can be selected using the <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> function with the proper parameter. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a2a3c0067e44c5ef3210a256d06c16b0fad263caec619c4d99e4684ba0fabd9493"></a><!-- doxytag: member="PUSH" ref="a2a3c0067e44c5ef3210a256d06c16b0fad263caec619c4d99e4684ba0fabd9493" args="" -->PUSH</em>&nbsp;</td><td>
<p>Local push operations are used, i.e. flow is moved only on one admissible arc at once. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2a3c0067e44c5ef3210a256d06c16b0facd2e1aa2398886ced14024f626167b10"></a><!-- doxytag: member="AUGMENT" ref="a2a3c0067e44c5ef3210a256d06c16b0facd2e1aa2398886ced14024f626167b10" args="" -->AUGMENT</em>&nbsp;</td><td>
<p>Augment operations are used, i.e. flow is moved on admissible paths from a node with excess to a node with deficit. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2a3c0067e44c5ef3210a256d06c16b0fad4476e3f57a85ac799fa83de6730c665"></a><!-- doxytag: member="PARTIAL_AUGMENT" ref="a2a3c0067e44c5ef3210a256d06c16b0fad4476e3f57a85ac799fa83de6730c665" args="" -->PARTIAL_AUGMENT</em>&nbsp;</td><td>
<p>Partial augment operations are used, i.e. flow is moved on admissible paths started from a node with excess, but the lengths of these paths are limited. This method can be viewed as a combined version of the previous two operations. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aef36da2d5f6a91d3c945078c91a00f29"></a><!-- doxytag: member="lemon::CostScaling::CostScaling" ref="aef36da2d5f6a91d3c945078c91a00f29" args="(const GR &amp;graph)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html">CostScaling</a> </td>
          <td>(</td>
          <td class="paramtype">const GR &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The constructor of the class.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The digraph the algorithm runs on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aec87dc6ef6c33e4ada265b63bc212224"></a><!-- doxytag: member="lemon::CostScaling::lowerMap" ref="aec87dc6ef6c33e4ada265b63bc212224" args="(const LowerMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html">CostScaling</a>&amp; lowerMap </td>
          <td>(</td>
          <td class="paramtype">const LowerMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the lower bounds on the arcs. If it is not used before calling <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a>, the lower bounds will be set to zero on all arcs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>An arc map storing the lower bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a82c76205dd2bbd823ea4bde64e043599"></a><!-- doxytag: member="lemon::CostScaling::upperMap" ref="a82c76205dd2bbd823ea4bde64e043599" args="(const UpperMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html">CostScaling</a>&amp; upperMap </td>
          <td>(</td>
          <td class="paramtype">const UpperMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the upper bounds (capacities) on the arcs. If it is not used before calling <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a>, the upper bounds will be set to <a class="el" href="a00086.html#a601ffd79f13610daacadd46f973507c5">INF</a> on all arcs (i.e. the flow value will be unbounded from above).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>An arc map storing the upper bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a541ff34efc2aef2ca5c27c2183955909"></a><!-- doxytag: member="lemon::CostScaling::costMap" ref="a541ff34efc2aef2ca5c27c2183955909" args="(const CostMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html">CostScaling</a>&amp; costMap </td>
          <td>(</td>
          <td class="paramtype">const CostMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the costs of the arcs. If it is not used before calling <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a>, the costs will be set to <code>1</code> on all arcs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>An arc map storing the costs. Its <code>Value</code> type must be convertible to the <code>Cost</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8613005e2f06793a1870f0acf4f9673"></a><!-- doxytag: member="lemon::CostScaling::supplyMap" ref="ad8613005e2f06793a1870f0acf4f9673" args="(const SupplyMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html">CostScaling</a>&amp; supplyMap </td>
          <td>(</td>
          <td class="paramtype">const SupplyMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the supply values of the nodes. If neither this function nor <a class="el" href="a00086.html#a606e5cc8a41acd2f6f0998c096e79a0d">stSupply()</a> is used before calling <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a>, the supply of each node will be set to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>A node map storing the supply values. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a606e5cc8a41acd2f6f0998c096e79a0d"></a><!-- doxytag: member="lemon::CostScaling::stSupply" ref="a606e5cc8a41acd2f6f0998c096e79a0d" args="(const Node &amp;s, const Node &amp;t, Value k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html">CostScaling</a>&amp; stSupply </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00086.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets a single source node and a single target node and the required flow value. If neither this function nor <a class="el" href="a00086.html#ad8613005e2f06793a1870f0acf4f9673">supplyMap()</a> is used before calling <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a>, the supply of each node will be set to zero.</p>
<p>Using this function has the same effect as using <a class="el" href="a00086.html#ad8613005e2f06793a1870f0acf4f9673">supplyMap()</a> with such a map in which <code>k</code> is assigned to <code>s</code>, <code>-k</code> is assigned to <code>t</code> and all other nodes have zero supply value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The source node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The target node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The required amount of flow from node <code>s</code> to node <code>t</code> (i.e. the supply of <code>s</code> and the demand of <code>t</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a05f1f2fac9f40760afbd2fb3af51f2b3"></a><!-- doxytag: member="lemon::CostScaling::run" ref="a05f1f2fac9f40760afbd2fb3af51f2b3" args="(Method method=PARTIAL_AUGMENT, int factor=8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a>&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>PARTIAL_AUGMENT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>factor</em> = <code>8</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function runs the algorithm. The paramters can be specified using functions <a class="el" href="a00086.html#aec87dc6ef6c33e4ada265b63bc212224">lowerMap()</a>, <a class="el" href="a00086.html#a82c76205dd2bbd823ea4bde64e043599">upperMap()</a>, <a class="el" href="a00086.html#a541ff34efc2aef2ca5c27c2183955909">costMap()</a>, <a class="el" href="a00086.html#ad8613005e2f06793a1870f0acf4f9673">supplyMap()</a>, <a class="el" href="a00086.html#a606e5cc8a41acd2f6f0998c096e79a0d">stSupply()</a>. For example, </p>
<div class="fragment"><pre class="fragment">   CostScaling&lt;ListDigraph&gt; cs(graph);
   cs.lowerMap(lower).upperMap(upper).costMap(cost)
     .supplyMap(sup).run();
</pre></div><p>This function can be called more than once. All the given parameters are kept for the next call, unless <a class="el" href="a00086.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams()</a> or <a class="el" href="a00086.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> is used, thus only the modified parameters have to be set again. If the underlying digraph was also modified after the construction of the class (or the last <a class="el" href="a00086.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> call), then the <a class="el" href="a00086.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> function must be called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>The internal method that will be used in the algorithm. For more information, see <a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>factor</em>&nbsp;</td><td>The cost scaling factor. It must be larger than one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>INFEASIBLE</code> if no feasible flow exists, <br/>
 <code>OPTIMAL</code> if the problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions), <br/>
 <code>UNBOUNDED</code> if the digraph contains an arc of negative cost and infinite upper bound. It means that the objective function is unbounded on that arc, however, note that it could actually be bounded over the feasible flows, but this algroithm cannot handle these cases.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00086.html#a4c669cb1cb4d98dfea944e9ceec7d33e" title="Problem type constants for the run() function.">ProblemType</a>, <a class="el" href="a00086.html#a2a3c0067e44c5ef3210a256d06c16b0f" title="Constants for selecting the internal method.">Method</a> </dd>
<dd>
<a class="el" href="a00086.html#a3da4b33bee24846e97c4fad32696d7b2" title="Reset all the parameters that have been given before.">resetParams()</a>, <a class="el" href="a00086.html#aec24c3696fc3c1818effd0523dffa452" title="Reset all the parameters that have been given before.">reset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3da4b33bee24846e97c4fad32696d7b2"></a><!-- doxytag: member="lemon::CostScaling::resetParams" ref="a3da4b33bee24846e97c4fad32696d7b2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html">CostScaling</a>&amp; resetParams </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets all the paramaters that have been given before using functions <a class="el" href="a00086.html#aec87dc6ef6c33e4ada265b63bc212224">lowerMap()</a>, <a class="el" href="a00086.html#a82c76205dd2bbd823ea4bde64e043599">upperMap()</a>, <a class="el" href="a00086.html#a541ff34efc2aef2ca5c27c2183955909">costMap()</a>, <a class="el" href="a00086.html#ad8613005e2f06793a1870f0acf4f9673">supplyMap()</a>, <a class="el" href="a00086.html#a606e5cc8a41acd2f6f0998c096e79a0d">stSupply()</a>.</p>
<p>It is useful for multiple <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> calls. Basically, all the given parameters are kept for the next <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> call, unless <a class="el" href="a00086.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams()</a> or <a class="el" href="a00086.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a00086.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> call, then the <a class="el" href="a00086.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> function must be used, otherwise <a class="el" href="a00086.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams()</a> is sufficient.</p>
<p>For example, </p>
<div class="fragment"><pre class="fragment">   CostScaling&lt;ListDigraph&gt; cs(graph);

   <span class="comment">// First run</span>
   cs.lowerMap(lower).upperMap(upper).costMap(cost)
     .supplyMap(sup).run();

   <span class="comment">// Run again with modified cost map (resetParams() is not called,</span>
   <span class="comment">// so only the cost map have to be set again)</span>
   cost[e] += 100;
   cs.costMap(cost).run();

   <span class="comment">// Run again from scratch using resetParams()</span>
   <span class="comment">// (the lower bounds will be set to zero on all arcs)</span>
   cs.resetParams();
   cs.upperMap(capacity).costMap(cost)
     .supplyMap(sup).run();
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00086.html#aec24c3696fc3c1818effd0523dffa452" title="Reset all the parameters that have been given before.">reset()</a>, <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3" title="Run the algorithm.">run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aec24c3696fc3c1818effd0523dffa452"></a><!-- doxytag: member="lemon::CostScaling::reset" ref="aec24c3696fc3c1818effd0523dffa452" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html">CostScaling</a>&amp; reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets all the paramaters that have been given before using functions <a class="el" href="a00086.html#aec87dc6ef6c33e4ada265b63bc212224">lowerMap()</a>, <a class="el" href="a00086.html#a82c76205dd2bbd823ea4bde64e043599">upperMap()</a>, <a class="el" href="a00086.html#a541ff34efc2aef2ca5c27c2183955909">costMap()</a>, <a class="el" href="a00086.html#ad8613005e2f06793a1870f0acf4f9673">supplyMap()</a>, <a class="el" href="a00086.html#a606e5cc8a41acd2f6f0998c096e79a0d">stSupply()</a>.</p>
<p>It is useful for multiple <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3" title="Run the algorithm.">run()</a> calls. If this function is not used, all the parameters given before are kept for the next <a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> call. However, the underlying digraph must not be modified after this class have been constructed, since it copies and extends the graph. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a53bae6343367680cea8a37c2f6cd17b3"></a><!-- doxytag: member="lemon::CostScaling::totalCost" ref="a53bae6343367680cea8a37c2f6cd17b3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Number totalCost </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the total cost of the found flow. Its complexity is O(e).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The return type of the function can be specified as a template parameter. For example, <div class="fragment"><pre class="fragment">   cs.totalCost&lt;<span class="keywordtype">double</span>&gt;();
</pre></div> It is useful if the total cost cannot be stored in the <code>Cost</code> type of the algorithm, which is the default return type of the function.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fc53c0667fdfb95dadd6a302f045941"></a><!-- doxytag: member="lemon::CostScaling::flow" ref="a7fc53c0667fdfb95dadd6a302f045941" args="(const Arc &amp;a) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> flow </td>
          <td>(</td>
          <td class="paramtype">const Arc &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the flow on the given arc.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bacd75ff1778bdc0a2c3ab0d0d00f36"></a><!-- doxytag: member="lemon::CostScaling::flowMap" ref="a0bacd75ff1778bdc0a2c3ab0d0d00f36" args="(FlowMap &amp;map) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flowMap </td>
          <td>(</td>
          <td class="paramtype">FlowMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function copies the flow value on each arc into the given map. The <code>Value</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ac97efaa2b500bb002f116bf4ba7c9b0b"></a><!-- doxytag: member="lemon::CostScaling::potential" ref="ac97efaa2b500bb002f116bf4ba7c9b0b" args="(const Node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00086.html#a9142822eba184f2778b6aac70b0900b3">Cost</a> potential </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the potential (dual value) of the given node.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a5011146c7986300cf2a684fb7aa8419a"></a><!-- doxytag: member="lemon::CostScaling::potentialMap" ref="a5011146c7986300cf2a684fb7aa8419a" args="(PotentialMap &amp;map) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void potentialMap </td>
          <td>(</td>
          <td class="paramtype">PotentialMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function copies the potential (dual value) of each node into the given map. The <code>Cost</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00086.html#a05f1f2fac9f40760afbd2fb3af51f2b3">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a601ffd79f13610daacadd46f973507c5"></a><!-- doxytag: member="lemon::CostScaling::INF" ref="a601ffd79f13610daacadd46f973507c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00086.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> <a class="el" href="a00086.html#a601ffd79f13610daacadd46f973507c5">INF</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constant for infinite upper bounds (capacities). It is <code>std::numeric_limits&lt;Value&gt;::infinity()</code> if available, <code>std::numeric_limits&lt;Value&gt;::max()</code> otherwise. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
