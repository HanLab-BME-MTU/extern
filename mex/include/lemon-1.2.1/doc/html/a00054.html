<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LEMON: CapacityScaling&lt; GR, V, C, TR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a00496.html">lemon</a>      </li>
      <li><a class="el" href="a00054.html">CapacityScaling&lt; GR, V, C, TR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>CapacityScaling&lt; GR, V, C, TR &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00534.html">Minimum Cost Flow Algorithms</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="lemon::CapacityScaling" --><hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename GR, typename V, typename C, typename TR&gt;<br/>
 class lemon::CapacityScaling&lt; GR, V, C, TR &gt;</h3>

<p><a class="el" href="a00054.html">CapacityScaling</a> implements the capacity scaling version of the successive shortest path algorithm for finding a <a class="el" href="a00005.html">minimum cost flow</a> <a class="el" href="a00007.html#amo93networkflows">[AMO93]</a>, <a class="el" href="a00007.html#edmondskarp72theoretical">[EK72]</a>. It is an efficient dual solution method.</p>
<p>Most of the parameters of the problem (except for the digraph) can be given using separate functions, and the algorithm can be executed using the <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> function. If some parameters are not specified, then default values will be used.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>GR</em>&nbsp;</td><td>The digraph type the algorithm runs on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>The number type used for flow amounts, capacity bounds and supply values in the algorithm. By default, it is <code>int</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>The number type used for costs and potentials in the algorithm. By default, it is the same as <code>V</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TR</em>&nbsp;</td><td>The traits class that defines various types used by the algorithm. By default, it is <a class="el" href="a00055.html">CapacityScalingDefaultTraits&lt;GR, V, C&gt;</a>. In most cases, this parameter should not be set directly, consider to use the named template parameters instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Both number types must be signed and all input data must be integer. </dd>
<dd>
This algorithm does not support negative costs for such arcs that have infinite upper bound. </dd></dl>

<p><code>#include &lt;lemon/capacity_scaling.h&gt;</code></p>

<p><a href="a00619.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html">SetHeap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting <code>Heap</code> type.  <a href="a00298.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> { <a class="el" href="a00054.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483">INFEASIBLE</a>, 
<a class="el" href="a00054.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad">OPTIMAL</a>, 
<a class="el" href="a00054.html#a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef">UNBOUNDED</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Problem type constants for the <code><a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d" title="Run the algorithm.">run()</a></code> function. </p>
 <a href="a00054.html#a4c669cb1cb4d98dfea944e9ceec7d33e">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a750f38b47fd56ef715849c3bd77fbe77"></a><!-- doxytag: member="lemon::CapacityScaling::Digraph" ref="a750f38b47fd56ef715849c3bd77fbe77" args="" -->
typedef TR::Digraph&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the digraph. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2042899ede28a8f6f0fdceb92a7d3c2"></a><!-- doxytag: member="lemon::CapacityScaling::Value" ref="aa2042899ede28a8f6f0fdceb92a7d3c2" args="" -->
typedef TR::Value&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the flow amounts, capacity bounds and supply values. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9142822eba184f2778b6aac70b0900b3"></a><!-- doxytag: member="lemon::CapacityScaling::Cost" ref="a9142822eba184f2778b6aac70b0900b3" args="" -->
typedef TR::Cost&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a9142822eba184f2778b6aac70b0900b3">Cost</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the arc costs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1e3f1c47cd4bffb15e3bbc452585f7c"></a><!-- doxytag: member="lemon::CapacityScaling::Heap" ref="ab1e3f1c47cd4bffb15e3bbc452585f7c" args="" -->
typedef TR::Heap&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#ab1e3f1c47cd4bffb15e3bbc452585f7c">Heap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the heap used for internal <a class="el" href="a00110.html" title="Dijkstra algorithm class.">Dijkstra</a> computations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab157e5452122f7a7f73dfda5ed931d69"></a><!-- doxytag: member="lemon::CapacityScaling::Traits" ref="ab157e5452122f7a7f73dfda5ed931d69" args="" -->
typedef TR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#ab157e5452122f7a7f73dfda5ed931d69">Traits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00055.html">traits class</a> of the algorithm. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#ac44b4786c702ac531e5c6bb86273c60e">CapacityScaling</a> (const GR &amp;graph)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#ac44b4786c702ac531e5c6bb86273c60e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Parameters</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp3225a10b07f1580f10dee4abc3779e6c"></a> The parameters of the algorithm can be specified using these functions. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LowerMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00054.html">CapacityScaling</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00054.html#a3cdf1bc8c066daa6d1c56dacb0aa5004">lowerMap</a> (const LowerMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the lower bounds on the arcs.  <a href="#a3cdf1bc8c066daa6d1c56dacb0aa5004"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename UpperMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00054.html">CapacityScaling</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00054.html#a832eddcdc7d17a98bbe6b958cb56a9cf">upperMap</a> (const UpperMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the upper bounds (capacities) on the arcs.  <a href="#a832eddcdc7d17a98bbe6b958cb56a9cf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CostMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00054.html">CapacityScaling</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00054.html#a374d2c90df7ca4373651de38cf2a1541">costMap</a> (const CostMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the costs of the arcs.  <a href="#a374d2c90df7ca4373651de38cf2a1541"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SupplyMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00054.html">CapacityScaling</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00054.html#a8d0d9c46e375a0824b17634c442b65ef">supplyMap</a> (const SupplyMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the supply values of the nodes.  <a href="#a8d0d9c46e375a0824b17634c442b65ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">CapacityScaling</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a412fea5aa104e9826ddeec1fa54d528d">stSupply</a> (const Node &amp;s, const Node &amp;t, <a class="el" href="a00054.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set single source and target nodes and a supply value.  <a href="#a412fea5aa104e9826ddeec1fa54d528d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpfb61d1f5bc43a30e898d23cf770546c2"></a> The algorithm can be executed using <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a>. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run</a> (int factor=4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run the algorithm.  <a href="#a9f51b418026d5480f76426f974567c5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">CapacityScaling</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#ac33087a2f4ddc981c4a977a291f8973a">resetParams</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset all the parameters that have been given before.  <a href="#ac33087a2f4ddc981c4a977a291f8973a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html">CapacityScaling</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the internal data structures and all the parameters that have been given before.  <a href="#af24760b2df0ab9357ce068be8a4f47c3"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9842fe246fad3ca12bcafafc2b70d75"></a> The results of the algorithm can be obtained using these functions.<br/>
 The <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> function must be called before using them. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Number&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00054.html#a53bae6343367680cea8a37c2f6cd17b3">totalCost</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the total cost of the found flow.  <a href="#a53bae6343367680cea8a37c2f6cd17b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a7fc53c0667fdfb95dadd6a302f045941">flow</a> (const Arc &amp;a) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the flow on the given arc.  <a href="#a7fc53c0667fdfb95dadd6a302f045941"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FlowMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00054.html#a0bacd75ff1778bdc0a2c3ab0d0d00f36">flowMap</a> (FlowMap &amp;map) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the flow map (the primal solution).  <a href="#a0bacd75ff1778bdc0a2c3ab0d0d00f36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00054.html#a9142822eba184f2778b6aac70b0900b3">Cost</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#ac97efaa2b500bb002f116bf4ba7c9b0b">potential</a> (const Node &amp;n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the potential (dual value) of the given node.  <a href="#ac97efaa2b500bb002f116bf4ba7c9b0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PotentialMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00054.html#a5011146c7986300cf2a684fb7aa8419a">potentialMap</a> (PotentialMap &amp;map) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the potential map (the dual solution).  <a href="#a5011146c7986300cf2a684fb7aa8419a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00054.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html#a601ffd79f13610daacadd46f973507c5">INF</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant for infinite upper bounds (capacities).  <a href="#a601ffd79f13610daacadd46f973507c5"></a><br/></td></tr>
</table>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33e"></a><!-- doxytag: member="lemon::CapacityScaling::ProblemType" ref="a4c669cb1cb4d98dfea944e9ceec7d33e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00054.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum type containing the problem type constants that can be returned by the <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> function of the algorithm. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483"></a><!-- doxytag: member="INFEASIBLE" ref="a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483" args="" -->INFEASIBLE</em>&nbsp;</td><td>
<p>The problem has no feasible solution (flow). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad"></a><!-- doxytag: member="OPTIMAL" ref="a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad" args="" -->OPTIMAL</em>&nbsp;</td><td>
<p>The problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef"></a><!-- doxytag: member="UNBOUNDED" ref="a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef" args="" -->UNBOUNDED</em>&nbsp;</td><td>
<p>The digraph contains an arc of negative cost and infinite upper bound. It means that the objective function is unbounded on that arc, however, note that it could actually be bounded over the feasible flows, but this algroithm cannot handle these cases. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac44b4786c702ac531e5c6bb86273c60e"></a><!-- doxytag: member="lemon::CapacityScaling::CapacityScaling" ref="ac44b4786c702ac531e5c6bb86273c60e" args="(const GR &amp;graph)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">CapacityScaling</a> </td>
          <td>(</td>
          <td class="paramtype">const GR &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The constructor of the class.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The digraph the algorithm runs on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3cdf1bc8c066daa6d1c56dacb0aa5004"></a><!-- doxytag: member="lemon::CapacityScaling::lowerMap" ref="a3cdf1bc8c066daa6d1c56dacb0aa5004" args="(const LowerMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">CapacityScaling</a>&amp; lowerMap </td>
          <td>(</td>
          <td class="paramtype">const LowerMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the lower bounds on the arcs. If it is not used before calling <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a>, the lower bounds will be set to zero on all arcs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>An arc map storing the lower bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a832eddcdc7d17a98bbe6b958cb56a9cf"></a><!-- doxytag: member="lemon::CapacityScaling::upperMap" ref="a832eddcdc7d17a98bbe6b958cb56a9cf" args="(const UpperMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">CapacityScaling</a>&amp; upperMap </td>
          <td>(</td>
          <td class="paramtype">const UpperMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the upper bounds (capacities) on the arcs. If it is not used before calling <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a>, the upper bounds will be set to <a class="el" href="a00054.html#a601ffd79f13610daacadd46f973507c5">INF</a> on all arcs (i.e. the flow value will be unbounded from above).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>An arc map storing the upper bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a374d2c90df7ca4373651de38cf2a1541"></a><!-- doxytag: member="lemon::CapacityScaling::costMap" ref="a374d2c90df7ca4373651de38cf2a1541" args="(const CostMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">CapacityScaling</a>&amp; costMap </td>
          <td>(</td>
          <td class="paramtype">const CostMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the costs of the arcs. If it is not used before calling <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a>, the costs will be set to <code>1</code> on all arcs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>An arc map storing the costs. Its <code>Value</code> type must be convertible to the <code>Cost</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a8d0d9c46e375a0824b17634c442b65ef"></a><!-- doxytag: member="lemon::CapacityScaling::supplyMap" ref="a8d0d9c46e375a0824b17634c442b65ef" args="(const SupplyMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">CapacityScaling</a>&amp; supplyMap </td>
          <td>(</td>
          <td class="paramtype">const SupplyMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the supply values of the nodes. If neither this function nor <a class="el" href="a00054.html#a412fea5aa104e9826ddeec1fa54d528d">stSupply()</a> is used before calling <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a>, the supply of each node will be set to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>A node map storing the supply values. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a412fea5aa104e9826ddeec1fa54d528d"></a><!-- doxytag: member="lemon::CapacityScaling::stSupply" ref="a412fea5aa104e9826ddeec1fa54d528d" args="(const Node &amp;s, const Node &amp;t, Value k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">CapacityScaling</a>&amp; stSupply </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00054.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets a single source node and a single target node and the required flow value. If neither this function nor <a class="el" href="a00054.html#a8d0d9c46e375a0824b17634c442b65ef">supplyMap()</a> is used before calling <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a>, the supply of each node will be set to zero.</p>
<p>Using this function has the same effect as using <a class="el" href="a00054.html#a8d0d9c46e375a0824b17634c442b65ef">supplyMap()</a> with such a map in which <code>k</code> is assigned to <code>s</code>, <code>-k</code> is assigned to <code>t</code> and all other nodes have zero supply value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The source node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The target node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The required amount of flow from node <code>s</code> to node <code>t</code> (i.e. the supply of <code>s</code> and the demand of <code>t</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a9f51b418026d5480f76426f974567c5d"></a><!-- doxytag: member="lemon::CapacityScaling::run" ref="a9f51b418026d5480f76426f974567c5d" args="(int factor=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> run </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>factor</em> = <code>4</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function runs the algorithm. The paramters can be specified using functions <a class="el" href="a00054.html#a3cdf1bc8c066daa6d1c56dacb0aa5004">lowerMap()</a>, <a class="el" href="a00054.html#a832eddcdc7d17a98bbe6b958cb56a9cf">upperMap()</a>, <a class="el" href="a00054.html#a374d2c90df7ca4373651de38cf2a1541">costMap()</a>, <a class="el" href="a00054.html#a8d0d9c46e375a0824b17634c442b65ef">supplyMap()</a>, <a class="el" href="a00054.html#a412fea5aa104e9826ddeec1fa54d528d">stSupply()</a>. For example, </p>
<div class="fragment"><pre class="fragment">   CapacityScaling&lt;ListDigraph&gt; cs(graph);
   cs.lowerMap(lower).upperMap(upper).costMap(cost)
     .supplyMap(sup).run();
</pre></div><p>This function can be called more than once. All the given parameters are kept for the next call, unless <a class="el" href="a00054.html#ac33087a2f4ddc981c4a977a291f8973a">resetParams()</a> or <a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3">reset()</a> is used, thus only the modified parameters have to be set again. If the underlying digraph was also modified after the construction of the class (or the last <a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3">reset()</a> call), then the <a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3">reset()</a> function must be called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>factor</em>&nbsp;</td><td>The capacity scaling factor. It must be larger than one to use scaling. If it is less or equal to one, then scaling will be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>INFEASIBLE</code> if no feasible flow exists, <br/>
 <code>OPTIMAL</code> if the problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions), <br/>
 <code>UNBOUNDED</code> if the digraph contains an arc of negative cost and infinite upper bound. It means that the objective function is unbounded on that arc, however, note that it could actually be bounded over the feasible flows, but this algroithm cannot handle these cases.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00054.html#a4c669cb1cb4d98dfea944e9ceec7d33e" title="Problem type constants for the run() function.">ProblemType</a> </dd>
<dd>
<a class="el" href="a00054.html#ac33087a2f4ddc981c4a977a291f8973a" title="Reset all the parameters that have been given before.">resetParams()</a>, <a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3" title="Reset the internal data structures and all the parameters that have been given before.">reset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac33087a2f4ddc981c4a977a291f8973a"></a><!-- doxytag: member="lemon::CapacityScaling::resetParams" ref="ac33087a2f4ddc981c4a977a291f8973a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">CapacityScaling</a>&amp; resetParams </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets all the paramaters that have been given before using functions <a class="el" href="a00054.html#a3cdf1bc8c066daa6d1c56dacb0aa5004">lowerMap()</a>, <a class="el" href="a00054.html#a832eddcdc7d17a98bbe6b958cb56a9cf">upperMap()</a>, <a class="el" href="a00054.html#a374d2c90df7ca4373651de38cf2a1541">costMap()</a>, <a class="el" href="a00054.html#a8d0d9c46e375a0824b17634c442b65ef">supplyMap()</a>, <a class="el" href="a00054.html#a412fea5aa104e9826ddeec1fa54d528d">stSupply()</a>.</p>
<p>It is useful for multiple <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> calls. Basically, all the given parameters are kept for the next <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> call, unless <a class="el" href="a00054.html#ac33087a2f4ddc981c4a977a291f8973a">resetParams()</a> or <a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3">reset()</a> call, then the <a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3">reset()</a> function must be used, otherwise <a class="el" href="a00054.html#ac33087a2f4ddc981c4a977a291f8973a">resetParams()</a> is sufficient.</p>
<p>For example, </p>
<div class="fragment"><pre class="fragment">   CapacityScaling&lt;ListDigraph&gt; cs(graph);

   <span class="comment">// First run</span>
   cs.lowerMap(lower).upperMap(upper).costMap(cost)
     .supplyMap(sup).run();

   <span class="comment">// Run again with modified cost map (resetParams() is not called,</span>
   <span class="comment">// so only the cost map have to be set again)</span>
   cost[e] += 100;
   cs.costMap(cost).run();

   <span class="comment">// Run again from scratch using resetParams()</span>
   <span class="comment">// (the lower bounds will be set to zero on all arcs)</span>
   cs.resetParams();
   cs.upperMap(capacity).costMap(cost)
     .supplyMap(sup).run();
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3" title="Reset the internal data structures and all the parameters that have been given before.">reset()</a>, <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d" title="Run the algorithm.">run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af24760b2df0ab9357ce068be8a4f47c3"></a><!-- doxytag: member="lemon::CapacityScaling::reset" ref="af24760b2df0ab9357ce068be8a4f47c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">CapacityScaling</a>&amp; reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets the internal data structures and all the paramaters that have been given before using functions <a class="el" href="a00054.html#a3cdf1bc8c066daa6d1c56dacb0aa5004">lowerMap()</a>, <a class="el" href="a00054.html#a832eddcdc7d17a98bbe6b958cb56a9cf">upperMap()</a>, <a class="el" href="a00054.html#a374d2c90df7ca4373651de38cf2a1541">costMap()</a>, <a class="el" href="a00054.html#a8d0d9c46e375a0824b17634c442b65ef">supplyMap()</a>, <a class="el" href="a00054.html#a412fea5aa104e9826ddeec1fa54d528d">stSupply()</a>.</p>
<p>It is useful for multiple <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> calls. Basically, all the given parameters are kept for the next <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> call, unless <a class="el" href="a00054.html#ac33087a2f4ddc981c4a977a291f8973a">resetParams()</a> or <a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3">reset()</a> call, then the <a class="el" href="a00054.html#af24760b2df0ab9357ce068be8a4f47c3">reset()</a> function must be used, otherwise <a class="el" href="a00054.html#ac33087a2f4ddc981c4a977a291f8973a">resetParams()</a> is sufficient.</p>
<p>See <a class="el" href="a00054.html#ac33087a2f4ddc981c4a977a291f8973a">resetParams()</a> for examples.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00054.html#ac33087a2f4ddc981c4a977a291f8973a" title="Reset all the parameters that have been given before.">resetParams()</a>, <a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d" title="Run the algorithm.">run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a53bae6343367680cea8a37c2f6cd17b3"></a><!-- doxytag: member="lemon::CapacityScaling::totalCost" ref="a53bae6343367680cea8a37c2f6cd17b3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Number totalCost </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the total cost of the found flow. Its complexity is O(e).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The return type of the function can be specified as a template parameter. For example, <div class="fragment"><pre class="fragment">   cs.totalCost&lt;<span class="keywordtype">double</span>&gt;();
</pre></div> It is useful if the total cost cannot be stored in the <code>Cost</code> type of the algorithm, which is the default return type of the function.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fc53c0667fdfb95dadd6a302f045941"></a><!-- doxytag: member="lemon::CapacityScaling::flow" ref="a7fc53c0667fdfb95dadd6a302f045941" args="(const Arc &amp;a) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> flow </td>
          <td>(</td>
          <td class="paramtype">const Arc &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the flow on the given arc.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bacd75ff1778bdc0a2c3ab0d0d00f36"></a><!-- doxytag: member="lemon::CapacityScaling::flowMap" ref="a0bacd75ff1778bdc0a2c3ab0d0d00f36" args="(FlowMap &amp;map) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flowMap </td>
          <td>(</td>
          <td class="paramtype">FlowMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function copies the flow value on each arc into the given map. The <code>Value</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ac97efaa2b500bb002f116bf4ba7c9b0b"></a><!-- doxytag: member="lemon::CapacityScaling::potential" ref="ac97efaa2b500bb002f116bf4ba7c9b0b" args="(const Node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html#a9142822eba184f2778b6aac70b0900b3">Cost</a> potential </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the potential (dual value) of the given node.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a5011146c7986300cf2a684fb7aa8419a"></a><!-- doxytag: member="lemon::CapacityScaling::potentialMap" ref="a5011146c7986300cf2a684fb7aa8419a" args="(PotentialMap &amp;map) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void potentialMap </td>
          <td>(</td>
          <td class="paramtype">PotentialMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function copies the potential (dual value) of each node into the given map. The <code>Cost</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00054.html#a9f51b418026d5480f76426f974567c5d">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a601ffd79f13610daacadd46f973507c5"></a><!-- doxytag: member="lemon::CapacityScaling::INF" ref="a601ffd79f13610daacadd46f973507c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00054.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> <a class="el" href="a00054.html#a601ffd79f13610daacadd46f973507c5">INF</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constant for infinite upper bounds (capacities). It is <code>std::numeric_limits&lt;Value&gt;::infinity()</code> if available, <code>std::numeric_limits&lt;Value&gt;::max()</code> otherwise. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
