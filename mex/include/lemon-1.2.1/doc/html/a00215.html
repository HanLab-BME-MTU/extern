<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LEMON: MaxFractionalMatching&lt; GR, TR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a00496.html">lemon</a>      </li>
      <li><a class="el" href="a00215.html">MaxFractionalMatching&lt; GR, TR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<h1>MaxFractionalMatching&lt; GR, TR &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00537.html">Matching Algorithms</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="lemon::MaxFractionalMatching" --><hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename GR, typename TR&gt;<br/>
 class lemon::MaxFractionalMatching&lt; GR, TR &gt;</h3>

<p>This class provides an implementation of fractional matching algorithm based on push-relabel principle.</p>
<p>The maximum cardinality fractional matching is a relaxation of the maximum cardinality matching problem where the odd set constraints are omitted. It can be formulated with the following linear program. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{e \in \delta(u)}x_e \le 1 \quad \forall u\in V\]" src="form_60.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[x_e \ge 0\quad \forall e\in E\]" src="form_61.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[\max \sum_{e\in E}x_e\]" src="form_62.png"/>
</p>
<p> where <img class="formulaInl" alt="$\delta(X)$" src="form_63.png"/> is the set of edges incident to a node in <img class="formulaInl" alt="$X$" src="form_7.png"/>. The result can be represented as the union of a matching with one value edges and a set of odd length cycles with half value edges.</p>
<p>The algorithm calculates an optimal fractional matching and a barrier. The number of adjacents of any node set minus the size of node set is a lower bound on the uncovered nodes in the graph. For maximum matching a barrier is computed which maximizes this difference.</p>
<p>The algorithm can be executed with the <a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6" title="Runs the algorithm.">run()</a> function. After it the matching (the primal solution) and the barrier (the dual solution) can be obtained using the query functions.</p>
<p>The primal solution is multiplied by <a class="el" href="a00215.html#aa437420dd0d9ef796d732dc5df70c008">2</a>.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>GR</em>&nbsp;</td><td>The undirected graph type the algorithm runs on. </td></tr>
  </table>
  </dd>
</dl>

<p><code>#include &lt;lemon/fractional_matching.h&gt;</code></p>

<p><a href="a00725.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00292.html">SetElevator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting <a class="el" href="a00126.html" title="Class for handling &quot;labels&quot; in push-relabel type algorithms.">Elevator</a> type  <a href="a00292.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00304.html">SetMatchingMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting MatchingMap type  <a href="a00304.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00326.html">SetStandardElevator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00006.html#named-templ-param">Named parameter</a> for setting <a class="el" href="a00126.html" title="Class for handling &quot;labels&quot; in push-relabel type algorithms.">Elevator</a> type with automatic allocation  <a href="a00326.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab157e5452122f7a7f73dfda5ed931d69"></a><!-- doxytag: member="lemon::MaxFractionalMatching::Traits" ref="ab157e5452122f7a7f73dfda5ed931d69" args="" -->
typedef TR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#ab157e5452122f7a7f73dfda5ed931d69">Traits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00216.html">traits</a> class" of the algorithm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81a6597ab6f942d117d2f32b1481e0de"></a><!-- doxytag: member="lemon::MaxFractionalMatching::Graph" ref="a81a6597ab6f942d117d2f32b1481e0de" args="" -->
typedef TR::Graph&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a81a6597ab6f942d117d2f32b1481e0de">Graph</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the graph the algorithm runs on. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9360c49ae8d8700a20e116842c238946"></a><!-- doxytag: member="lemon::MaxFractionalMatching::MatchingMap" ref="a9360c49ae8d8700a20e116842c238946" args="" -->
typedef TR::MatchingMap&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a9360c49ae8d8700a20e116842c238946">MatchingMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the matching map. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f28aefb0101865304e425890c6c4c68"></a><!-- doxytag: member="lemon::MaxFractionalMatching::Elevator" ref="a6f28aefb0101865304e425890c6c4c68" args="" -->
typedef TR::Elevator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a6f28aefb0101865304e425890c6c4c68">Elevator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the elevator. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a5fcc721fb672aa45f70b0a208bd0feeb">MaxFractionalMatching</a> (const <a class="el" href="a00215.html#a81a6597ab6f942d117d2f32b1481e0de">Graph</a> &amp;graph, bool allow_loops=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00215.html">MaxFractionalMatching</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a265db4699c294741b3fac13fd87683f9">matchingMap</a> (<a class="el" href="a00215.html#a9360c49ae8d8700a20e116842c238946">MatchingMap</a> &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the matching map.  <a href="#a265db4699c294741b3fac13fd87683f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00215.html">MaxFractionalMatching</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#aac65595b7a96924fb1f3136005686def">elevator</a> (<a class="el" href="a00215.html#a6f28aefb0101865304e425890c6c4c68">Elevator</a> &amp;elevator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the elevator used by algorithm.  <a href="#aac65595b7a96924fb1f3136005686def"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00215.html#a6f28aefb0101865304e425890c6c4c68">Elevator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a5dc9bfc4e3f3def6bd3daee725ac9d9a">elevator</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const reference to the elevator.  <a href="#a5dc9bfc4e3f3def6bd3daee725ac9d9a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpfb61d1f5bc43a30e898d23cf770546c2"></a> The simplest way to execute the algorithm is to use one of the member functions called <code><a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6" title="Runs the algorithm.">run()</a></code>. <br/>
 If you need more control on the execution, first you must call <a class="el" href="a00215.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> and then one variant of the <a class="el" href="a00215.html#a2b87bbc0b9cbd0fd9f193bee71984810" title="Starts the algorithm and computes a fractional matching.">start()</a> member. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the internal data structures.  <a href="#a02fd73d861ef2e4aabb38c0c9ff82947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a2b87bbc0b9cbd0fd9f193bee71984810">start</a> (bool postprocess=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the algorithm and computes a fractional matching.  <a href="#a2b87bbc0b9cbd0fd9f193bee71984810"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#ad384211fb3b06fea3a15bfc56454539b">startPerfect</a> (bool postprocess=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the algorithm and computes a perfect fractional matching.  <a href="#ad384211fb3b06fea3a15bfc56454539b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6">run</a> (bool postprocess=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runs the algorithm.  <a href="#a035e9e0f46f74123960b677fc4950fc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a26b5bcdd4b8017748eeef0d258c7264c">runPerfect</a> (bool postprocess=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runs the algorithm to find a perfect fractional matching.  <a href="#a26b5bcdd4b8017748eeef0d258c7264c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9842fe246fad3ca12bcafafc2b70d75"></a> The result of the Matching algorithm can be obtained using these functions.<br/>
 Before the use of these functions, either <a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6" title="Runs the algorithm.">run()</a> or <a class="el" href="a00215.html#a2b87bbc0b9cbd0fd9f193bee71984810" title="Starts the algorithm and computes a fractional matching.">start()</a> must be called. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a8be6dc29de917e74b2fcf7d452ec033d">matchingSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of covered nodes in the matching.  <a href="#a8be6dc29de917e74b2fcf7d452ec033d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00215.html#a9360c49ae8d8700a20e116842c238946">MatchingMap</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#ae64828409d8b38c61c9d134d3f139390">matchingMap</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const reference to the matching map.  <a href="#ae64828409d8b38c61c9d134d3f139390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a50c6e553126fcd65c0f177f6f9ea23de">matching</a> (const Edge &amp;edge) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if the given edge is in the matching.  <a href="#a50c6e553126fcd65c0f177f6f9ea23de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Arc&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#a20e6a43cb0c6c60ec37d39c627b8b662">matching</a> (const Node &amp;node) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the fractional matching arc (or edge) incident to the given node.  <a href="#a20e6a43cb0c6c60ec37d39c627b8b662"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#aaa0fa8205fb370cdc9ee3b33b1cd54a9">barrier</a> (const Node &amp;node) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the node is in the barrier.  <a href="#aaa0fa8205fb370cdc9ee3b33b1cd54a9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html#aa437420dd0d9ef796d732dc5df70c008">primalScale</a> = 2</td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5fcc721fb672aa45f70b0a208bd0feeb"></a><!-- doxytag: member="lemon::MaxFractionalMatching::MaxFractionalMatching" ref="a5fcc721fb672aa45f70b0a208bd0feeb" args="(const Graph &amp;graph, bool allow_loops=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00215.html">MaxFractionalMatching</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00215.html#a81a6597ab6f942d117d2f32b1481e0de">Graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allow_loops</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a265db4699c294741b3fac13fd87683f9"></a><!-- doxytag: member="lemon::MaxFractionalMatching::matchingMap" ref="a265db4699c294741b3fac13fd87683f9" args="(MatchingMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00215.html">MaxFractionalMatching</a>&amp; matchingMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00215.html#a9360c49ae8d8700a20e116842c238946">MatchingMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the matching map. If you don't use this function before calling <a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6">run()</a> or <a class="el" href="a00215.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, an instance will be allocated automatically. The destructor deallocates this automatically allocated map, of course. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aac65595b7a96924fb1f3136005686def"></a><!-- doxytag: member="lemon::MaxFractionalMatching::elevator" ref="aac65595b7a96924fb1f3136005686def" args="(Elevator &amp;elevator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00215.html">MaxFractionalMatching</a>&amp; elevator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00215.html#a6f28aefb0101865304e425890c6c4c68">Elevator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>elevator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the elevator used by algorithm. If you don't use this function before calling <a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6">run()</a> or <a class="el" href="a00215.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, an instance will be allocated automatically. The destructor deallocates this automatically allocated elevator, of course. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a5dc9bfc4e3f3def6bd3daee725ac9d9a"></a><!-- doxytag: member="lemon::MaxFractionalMatching::elevator" ref="a5dc9bfc4e3f3def6bd3daee725ac9d9a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00215.html#a6f28aefb0101865304e425890c6c4c68">Elevator</a>&amp; elevator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a const reference to the elevator.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6">run()</a> or <a class="el" href="a00215.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a02fd73d861ef2e4aabb38c0c9ff82947"></a><!-- doxytag: member="lemon::MaxFractionalMatching::init" ref="a02fd73d861ef2e4aabb38c0c9ff82947" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the internal data structures and sets the initial matching. </p>

</div>
</div>
<a class="anchor" id="a2b87bbc0b9cbd0fd9f193bee71984810"></a><!-- doxytag: member="lemon::MaxFractionalMatching::start" ref="a2b87bbc0b9cbd0fd9f193bee71984810" args="(bool postprocess=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>postprocess</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The algorithm computes a maximum fractional matching.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>postprocess</em>&nbsp;</td><td>The algorithm computes first a matching which is a union of a matching with one value edges, cycles with half value edges and even length paths with half value edges. If the parameter is true, then after the push-relabel algorithm it postprocesses the matching to contain only matching edges and half value odd cycles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad384211fb3b06fea3a15bfc56454539b"></a><!-- doxytag: member="lemon::MaxFractionalMatching::startPerfect" ref="ad384211fb3b06fea3a15bfc56454539b" args="(bool postprocess=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool startPerfect </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>postprocess</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The algorithm computes a perfect fractional matching. If it does not exists, then the algorithm returns false and the matching is undefined and the barrier.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>postprocess</em>&nbsp;</td><td>The algorithm computes first a matching which is a union of a matching with one value edges, cycles with half value edges and even length paths with half value edges. If the parameter is true, then after the push-relabel algorithm it postprocesses the matching to contain only matching edges and half value odd cycles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a035e9e0f46f74123960b677fc4950fc6"></a><!-- doxytag: member="lemon::MaxFractionalMatching::run" ref="a035e9e0f46f74123960b677fc4950fc6" args="(bool postprocess=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>postprocess</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Just a shortcut for the next code: </p>
<div class="fragment"><pre class="fragment">        <a class="code" href="a00215.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="Initializes the internal data structures.">init</a>();
        <a class="code" href="a00215.html#a2b87bbc0b9cbd0fd9f193bee71984810" title="Starts the algorithm and computes a fractional matching.">start</a>();
</pre></div> 
</div>
</div>
<a class="anchor" id="a26b5bcdd4b8017748eeef0d258c7264c"></a><!-- doxytag: member="lemon::MaxFractionalMatching::runPerfect" ref="a26b5bcdd4b8017748eeef0d258c7264c" args="(bool postprocess=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool runPerfect </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>postprocess</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Just a shortcut for the next code: </p>
<div class="fragment"><pre class="fragment">        <a class="code" href="a00215.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="Initializes the internal data structures.">init</a>();
        <a class="code" href="a00215.html#ad384211fb3b06fea3a15bfc56454539b" title="Starts the algorithm and computes a perfect fractional matching.">startPerfect</a>();
</pre></div> 
</div>
</div>
<a class="anchor" id="a8be6dc29de917e74b2fcf7d452ec033d"></a><!-- doxytag: member="lemon::MaxFractionalMatching::matchingSize" ref="a8be6dc29de917e74b2fcf7d452ec033d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matchingSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the number of covered nodes in the matching.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6" title="Runs the algorithm.">run()</a> or <a class="el" href="a00215.html#a2b87bbc0b9cbd0fd9f193bee71984810" title="Starts the algorithm and computes a fractional matching.">start()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ae64828409d8b38c61c9d134d3f139390"></a><!-- doxytag: member="lemon::MaxFractionalMatching::matchingMap" ref="ae64828409d8b38c61c9d134d3f139390" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00215.html#a9360c49ae8d8700a20e116842c238946">MatchingMap</a>&amp; matchingMap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a const reference to the node map storing the found fractional matching. This method can be called after running the algorithm.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6">run()</a> or <a class="el" href="a00215.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a50c6e553126fcd65c0f177f6f9ea23de"></a><!-- doxytag: member="lemon::MaxFractionalMatching::matching" ref="a50c6e553126fcd65c0f177f6f9ea23de" args="(const Edge &amp;edge) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matching </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&nbsp;</td>
          <td class="paramname"> <em>edge</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns <code>true</code> if the given edge is in the found matching. The result is scaled by <a class="el" href="a00215.html#aa437420dd0d9ef796d732dc5df70c008">primal scale</a>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6" title="Runs the algorithm.">run()</a> or <a class="el" href="a00215.html#a2b87bbc0b9cbd0fd9f193bee71984810" title="Starts the algorithm and computes a fractional matching.">start()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a20e6a43cb0c6c60ec37d39c627b8b662"></a><!-- doxytag: member="lemon::MaxFractionalMatching::matching" ref="a20e6a43cb0c6c60ec37d39c627b8b662" args="(const Node &amp;node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Arc matching </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns one of the fractional matching arc (or edge) incident to the given node in the found matching or <code>INVALID</code> if the node is not covered by the matching or if the node is on an odd length cycle then it is the successor edge on the cycle.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Either <a class="el" href="a00215.html#a035e9e0f46f74123960b677fc4950fc6" title="Runs the algorithm.">run()</a> or <a class="el" href="a00215.html#a2b87bbc0b9cbd0fd9f193bee71984810" title="Starts the algorithm and computes a fractional matching.">start()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa0fa8205fb370cdc9ee3b33b1cd54a9"></a><!-- doxytag: member="lemon::MaxFractionalMatching::barrier" ref="aaa0fa8205fb370cdc9ee3b33b1cd54a9" args="(const Node &amp;node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool barrier </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The barrier is a subset of the nodes. If the nodes in the barrier have less adjacent nodes than the size of the barrier, then at least as much nodes cannot be covered as the difference of the two subsets. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aa437420dd0d9ef796d732dc5df70c008"></a><!-- doxytag: member="lemon::MaxFractionalMatching::primalScale" ref="aa437420dd0d9ef796d732dc5df70c008" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00215.html#aa437420dd0d9ef796d732dc5df70c008">primalScale</a> = 2<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Scaling factor for primal solution. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
