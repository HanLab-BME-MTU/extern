<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LEMON: NetworkSimplex&lt; GR, V, C &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="a00496.html">lemon</a>      </li>
      <li><a class="el" href="a00231.html">NetworkSimplex&lt; GR, V, C &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>NetworkSimplex&lt; GR, V, C &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00534.html">Minimum Cost Flow Algorithms</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="lemon::NetworkSimplex" --><hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename GR, typename V = int, typename C = V&gt;<br/>
 class lemon::NetworkSimplex&lt; GR, V, C &gt;</h3>

<p><a class="el" href="a00231.html">NetworkSimplex</a> implements the primal Network Simplex algorithm for finding a <a class="el" href="a00005.html">minimum cost flow</a> <a class="el" href="a00007.html#amo93networkflows">[AMO93]</a>, <a class="el" href="a00007.html#dantzig63linearprog">[Dan63]</a>, <a class="el" href="a00007.html#kellyoneill91netsimplex">[KO91]</a>. This algorithm is a highly efficient specialized version of the linear programming simplex method directly for the minimum cost flow problem.</p>
<p>In general, NetworkSimplex is the fastest implementation available in LEMON for this problem. Moreover, it supports both directions of the supply/demand inequality constraints. For more information, see <a class="el" href="a00231.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a>.</p>
<p>Most of the parameters of the problem (except for the digraph) can be given using separate functions, and the algorithm can be executed using the <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> function. If some parameters are not specified, then default values will be used.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>GR</em>&nbsp;</td><td>The digraph type the algorithm runs on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>V</em>&nbsp;</td><td>The number type used for flow amounts, capacity bounds and supply values in the algorithm. By default, it is <code>int</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>The number type used for costs and potentials in the algorithm. By default, it is the same as <code>V</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Both number types must be signed and all input data must be integer.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>NetworkSimplex provides five different pivot rule implementations, from which the most efficient one is used by default. For more information, see <a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a>. </dd></dl>

<p><code>#include &lt;lemon/network_simplex.h&gt;</code></p>

<p><a href="a00914.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> { <a class="el" href="a00231.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483">INFEASIBLE</a>, 
<a class="el" href="a00231.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad">OPTIMAL</a>, 
<a class="el" href="a00231.html#a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef">UNBOUNDED</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Problem type constants for the <code><a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53" title="Run the algorithm.">run()</a></code> function. </p>
 <a href="a00231.html#a4c669cb1cb4d98dfea944e9ceec7d33e">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a> { <a class="el" href="a00231.html#ac860a45e09c68fb71f723d392c3161aca99705e9593e3e5c078150b293c86561e">GEQ</a>, 
<a class="el" href="a00231.html#ac860a45e09c68fb71f723d392c3161aca5eba1d52e68e10fb2dafcb363cec49b7">LEQ</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Constants for selecting the type of the supply constraints. </p>
 <a href="a00231.html#ac860a45e09c68fb71f723d392c3161ac">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2a7c31211b575a3beecd934538c4419b25">FIRST_ELIGIBLE</a>, 
<a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2ac89b3377964fb28026f9b814f30c210b">BEST_ELIGIBLE</a>, 
<a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2afa32a0f9c82dc3e2e1000b6086d3fc1c">BLOCK_SEARCH</a>, 
<a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2a8d608c7bc486d1c56c7e5a5a6c6a616d">CANDIDATE_LIST</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2a76eceb36ac871a19d694999a965f877a">ALTERING_LIST</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Constants for selecting the pivot rule. </p>
 <a href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c1768456283cc436140a9ffae849dd2"></a><!-- doxytag: member="lemon::NetworkSimplex::Value" ref="a6c1768456283cc436140a9ffae849dd2" args="" -->
typedef V&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a6c1768456283cc436140a9ffae849dd2">Value</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the flow amounts, capacity bounds and supply values. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeb81a88e6bbaf933ca20ea3bbba7a2c"></a><!-- doxytag: member="lemon::NetworkSimplex::Cost" ref="adeb81a88e6bbaf933ca20ea3bbba7a2c" args="" -->
typedef C&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#adeb81a88e6bbaf933ca20ea3bbba7a2c">Cost</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the arc costs. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a6f9eaf98674854b1428943ebb7e5a30d">NetworkSimplex</a> (const GR &amp;graph, bool arc_mixing=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a6f9eaf98674854b1428943ebb7e5a30d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Parameters</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp3225a10b07f1580f10dee4abc3779e6c"></a> The parameters of the algorithm can be specified using these functions. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LowerMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00231.html">NetworkSimplex</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a46572604302ad5db507870c2b11ab004">lowerMap</a> (const LowerMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the lower bounds on the arcs.  <a href="#a46572604302ad5db507870c2b11ab004"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename UpperMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00231.html">NetworkSimplex</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ace99ce94ec9eaa2f7e329d3547a5cb4e">upperMap</a> (const UpperMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the upper bounds (capacities) on the arcs.  <a href="#ace99ce94ec9eaa2f7e329d3547a5cb4e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CostMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00231.html">NetworkSimplex</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#af171423e38437c26404bd1f2ece0c83c">costMap</a> (const CostMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the costs of the arcs.  <a href="#af171423e38437c26404bd1f2ece0c83c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SupplyMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00231.html">NetworkSimplex</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a524e7594df8980eb0edcca44a2625769">supplyMap</a> (const SupplyMap &amp;map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the supply values of the nodes.  <a href="#a524e7594df8980eb0edcca44a2625769"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00231.html">NetworkSimplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#ac622127c2be52342b9becb61ff28e56e">stSupply</a> (const Node &amp;s, const Node &amp;t, <a class="el" href="a00231.html#a6c1768456283cc436140a9ffae849dd2">Value</a> k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set single source and target nodes and a supply value.  <a href="#ac622127c2be52342b9becb61ff28e56e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00231.html">NetworkSimplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a40c06e412dc08e6a541abbcf97385b1e">supplyType</a> (<a class="el" href="a00231.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a> supply_type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the type of the supply constraints.  <a href="#a40c06e412dc08e6a541abbcf97385b1e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution Control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd80b908dd00a6c6f28e1b1ee2d5fd269"></a> The algorithm can be executed using <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00231.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run</a> (<a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a> pivot_rule=BLOCK_SEARCH)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run the algorithm.  <a href="#a591276ea8f1afbe9d24bd1c1d48b0f53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00231.html">NetworkSimplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset all the parameters that have been given before.  <a href="#aefce8a05d41659d7aaffb4cb47eeec43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00231.html">NetworkSimplex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the internal data structures and all the parameters that have been given before.  <a href="#a88086127469093e19a9a024bbf60c360"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9842fe246fad3ca12bcafafc2b70d75"></a> The results of the algorithm can be obtained using these functions.<br/>
 The <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> function must be called before using them. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Number&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a53bae6343367680cea8a37c2f6cd17b3">totalCost</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the total cost of the found flow.  <a href="#a53bae6343367680cea8a37c2f6cd17b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00231.html#a6c1768456283cc436140a9ffae849dd2">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a7fc53c0667fdfb95dadd6a302f045941">flow</a> (const Arc &amp;a) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the flow on the given arc.  <a href="#a7fc53c0667fdfb95dadd6a302f045941"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FlowMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a0bacd75ff1778bdc0a2c3ab0d0d00f36">flowMap</a> (FlowMap &amp;map) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the flow map (the primal solution).  <a href="#a0bacd75ff1778bdc0a2c3ab0d0d00f36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00231.html#adeb81a88e6bbaf933ca20ea3bbba7a2c">Cost</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#ac97efaa2b500bb002f116bf4ba7c9b0b">potential</a> (const Node &amp;n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the potential (dual value) of the given node.  <a href="#ac97efaa2b500bb002f116bf4ba7c9b0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename PotentialMap &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a5011146c7986300cf2a684fb7aa8419a">potentialMap</a> (PotentialMap &amp;map) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the potential map (the dual solution).  <a href="#a5011146c7986300cf2a684fb7aa8419a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00231.html#a6c1768456283cc436140a9ffae849dd2">Value</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a601ffd79f13610daacadd46f973507c5">INF</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant for infinite upper bounds (capacities).  <a href="#a601ffd79f13610daacadd46f973507c5"></a><br/></td></tr>
</table>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33e"></a><!-- doxytag: member="lemon::NetworkSimplex::ProblemType" ref="a4c669cb1cb4d98dfea944e9ceec7d33e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum type containing the problem type constants that can be returned by the <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> function of the algorithm. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483"></a><!-- doxytag: member="INFEASIBLE" ref="a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483" args="" -->INFEASIBLE</em>&nbsp;</td><td>
<p>The problem has no feasible solution (flow). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad"></a><!-- doxytag: member="OPTIMAL" ref="a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad" args="" -->OPTIMAL</em>&nbsp;</td><td>
<p>The problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef"></a><!-- doxytag: member="UNBOUNDED" ref="a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef" args="" -->UNBOUNDED</em>&nbsp;</td><td>
<p>The objective function of the problem is unbounded, i.e. there is a directed cycle having negative total cost and infinite upper bound. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ac860a45e09c68fb71f723d392c3161ac"></a><!-- doxytag: member="lemon::NetworkSimplex::SupplyType" ref="ac860a45e09c68fb71f723d392c3161ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum type containing constants for selecting the supply type, i.e. the direction of the inequalities in the supply/demand constraints of the <a class="el" href="a00005.html">minimum cost flow problem</a>.</p>
<p>The default supply type is <code>GEQ</code>, the <code>LEQ</code> type can be selected using <a class="el" href="a00231.html#a40c06e412dc08e6a541abbcf97385b1e">supplyType()</a>. The equality form is a special case of both supply types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac860a45e09c68fb71f723d392c3161aca99705e9593e3e5c078150b293c86561e"></a><!-- doxytag: member="GEQ" ref="ac860a45e09c68fb71f723d392c3161aca99705e9593e3e5c078150b293c86561e" args="" -->GEQ</em>&nbsp;</td><td>
<p>This option means that there are <em>"greater or equal"</em> supply/demand constraints in the definition of the problem. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac860a45e09c68fb71f723d392c3161aca5eba1d52e68e10fb2dafcb363cec49b7"></a><!-- doxytag: member="LEQ" ref="ac860a45e09c68fb71f723d392c3161aca5eba1d52e68e10fb2dafcb363cec49b7" args="" -->LEQ</em>&nbsp;</td><td>
<p>This option means that there are <em>"less or equal"</em> supply/demand constraints in the definition of the problem. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2"></a><!-- doxytag: member="lemon::NetworkSimplex::PivotRule" ref="a310d3a1fcfff1e099330ae372abc73c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enum type containing constants for selecting the pivot rule for the <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> function.</p>
<p><a class="el" href="a00231.html">NetworkSimplex</a> provides five different pivot rule implementations that significantly affect the running time of the algorithm. By default, <a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2afa32a0f9c82dc3e2e1000b6086d3fc1c">Block Search</a> is used, which proved to be the most efficient and the most robust on various test inputs. However, another pivot rule can be selected using the <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> function with the proper parameter. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2a7c31211b575a3beecd934538c4419b25"></a><!-- doxytag: member="FIRST_ELIGIBLE" ref="a310d3a1fcfff1e099330ae372abc73c2a7c31211b575a3beecd934538c4419b25" args="" -->FIRST_ELIGIBLE</em>&nbsp;</td><td>
<p>The <em>First</em> <em>Eligible</em> pivot rule. The next eligible arc is selected in a wraparound fashion in every iteration. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2ac89b3377964fb28026f9b814f30c210b"></a><!-- doxytag: member="BEST_ELIGIBLE" ref="a310d3a1fcfff1e099330ae372abc73c2ac89b3377964fb28026f9b814f30c210b" args="" -->BEST_ELIGIBLE</em>&nbsp;</td><td>
<p>The <em>Best</em> <em>Eligible</em> pivot rule. The best eligible arc is selected in every iteration. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2afa32a0f9c82dc3e2e1000b6086d3fc1c"></a><!-- doxytag: member="BLOCK_SEARCH" ref="a310d3a1fcfff1e099330ae372abc73c2afa32a0f9c82dc3e2e1000b6086d3fc1c" args="" -->BLOCK_SEARCH</em>&nbsp;</td><td>
<p>The <em>Block</em> <em>Search</em> pivot rule. A specified number of arcs are examined in every iteration in a wraparound fashion and the best eligible arc is selected from this block. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2a8d608c7bc486d1c56c7e5a5a6c6a616d"></a><!-- doxytag: member="CANDIDATE_LIST" ref="a310d3a1fcfff1e099330ae372abc73c2a8d608c7bc486d1c56c7e5a5a6c6a616d" args="" -->CANDIDATE_LIST</em>&nbsp;</td><td>
<p>The <em>Candidate</em> <em>List</em> pivot rule. In a major iteration a candidate list is built from eligible arcs in a wraparound fashion and in the following minor iterations the best eligible arc is selected from this list. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2a76eceb36ac871a19d694999a965f877a"></a><!-- doxytag: member="ALTERING_LIST" ref="a310d3a1fcfff1e099330ae372abc73c2a76eceb36ac871a19d694999a965f877a" args="" -->ALTERING_LIST</em>&nbsp;</td><td>
<p>The <em>Altering</em> <em>Candidate</em> <em>List</em> pivot rule. It is a modified version of the Candidate List method. It keeps only the several best eligible arcs from the former candidate list and extends this list in every iteration. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6f9eaf98674854b1428943ebb7e5a30d"></a><!-- doxytag: member="lemon::NetworkSimplex::NetworkSimplex" ref="a6f9eaf98674854b1428943ebb7e5a30d" args="(const GR &amp;graph, bool arc_mixing=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html">NetworkSimplex</a> </td>
          <td>(</td>
          <td class="paramtype">const GR &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>arc_mixing</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The constructor of the class.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The digraph the algorithm runs on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arc_mixing</em>&nbsp;</td><td>Indicate if the arcs have to be stored in a mixed order in the internal data structure. In special cases, it could lead to better overall performance, but it is usually slower. Therefore it is disabled by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a46572604302ad5db507870c2b11ab004"></a><!-- doxytag: member="lemon::NetworkSimplex::lowerMap" ref="a46572604302ad5db507870c2b11ab004" args="(const LowerMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html">NetworkSimplex</a>&amp; lowerMap </td>
          <td>(</td>
          <td class="paramtype">const LowerMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the lower bounds on the arcs. If it is not used before calling <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the lower bounds will be set to zero on all arcs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>An arc map storing the lower bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ace99ce94ec9eaa2f7e329d3547a5cb4e"></a><!-- doxytag: member="lemon::NetworkSimplex::upperMap" ref="ace99ce94ec9eaa2f7e329d3547a5cb4e" args="(const UpperMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html">NetworkSimplex</a>&amp; upperMap </td>
          <td>(</td>
          <td class="paramtype">const UpperMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the upper bounds (capacities) on the arcs. If it is not used before calling <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the upper bounds will be set to <a class="el" href="a00231.html#a601ffd79f13610daacadd46f973507c5">INF</a> on all arcs (i.e. the flow value will be unbounded from above).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>An arc map storing the upper bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="af171423e38437c26404bd1f2ece0c83c"></a><!-- doxytag: member="lemon::NetworkSimplex::costMap" ref="af171423e38437c26404bd1f2ece0c83c" args="(const CostMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html">NetworkSimplex</a>&amp; costMap </td>
          <td>(</td>
          <td class="paramtype">const CostMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the costs of the arcs. If it is not used before calling <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the costs will be set to <code>1</code> on all arcs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>An arc map storing the costs. Its <code>Value</code> type must be convertible to the <code>Cost</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a524e7594df8980eb0edcca44a2625769"></a><!-- doxytag: member="lemon::NetworkSimplex::supplyMap" ref="a524e7594df8980eb0edcca44a2625769" args="(const SupplyMap &amp;map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html">NetworkSimplex</a>&amp; supplyMap </td>
          <td>(</td>
          <td class="paramtype">const SupplyMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the supply values of the nodes. If neither this function nor <a class="el" href="a00231.html#ac622127c2be52342b9becb61ff28e56e">stSupply()</a> is used before calling <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the supply of each node will be set to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>A node map storing the supply values. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ac622127c2be52342b9becb61ff28e56e"></a><!-- doxytag: member="lemon::NetworkSimplex::stSupply" ref="ac622127c2be52342b9becb61ff28e56e" args="(const Node &amp;s, const Node &amp;t, Value k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html">NetworkSimplex</a>&amp; stSupply </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00231.html#a6c1768456283cc436140a9ffae849dd2">Value</a>&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets a single source node and a single target node and the required flow value. If neither this function nor <a class="el" href="a00231.html#a524e7594df8980eb0edcca44a2625769">supplyMap()</a> is used before calling <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the supply of each node will be set to zero.</p>
<p>Using this function has the same effect as using <a class="el" href="a00231.html#a524e7594df8980eb0edcca44a2625769">supplyMap()</a> with such a map in which <code>k</code> is assigned to <code>s</code>, <code>-k</code> is assigned to <code>t</code> and all other nodes have zero supply value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The source node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The target node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The required amount of flow from node <code>s</code> to node <code>t</code> (i.e. the supply of <code>s</code> and the demand of <code>t</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a40c06e412dc08e6a541abbcf97385b1e"></a><!-- doxytag: member="lemon::NetworkSimplex::supplyType" ref="a40c06e412dc08e6a541abbcf97385b1e" args="(SupplyType supply_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html">NetworkSimplex</a>&amp; supplyType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00231.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a>&nbsp;</td>
          <td class="paramname"> <em>supply_type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the type of the supply/demand constraints. If it is not used before calling <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the <a class="el" href="a00231.html#ac860a45e09c68fb71f723d392c3161aca99705e9593e3e5c078150b293c86561e">GEQ</a> supply type will be used.</p>
<p>For more information, see <a class="el" href="a00231.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a591276ea8f1afbe9d24bd1c1d48b0f53"></a><!-- doxytag: member="lemon::NetworkSimplex::run" ref="a591276ea8f1afbe9d24bd1c1d48b0f53" args="(PivotRule pivot_rule=BLOCK_SEARCH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a>&nbsp;</td>
          <td class="paramname"> <em>pivot_rule</em> = <code>BLOCK_SEARCH</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function runs the algorithm. The paramters can be specified using functions <a class="el" href="a00231.html#a46572604302ad5db507870c2b11ab004">lowerMap()</a>, <a class="el" href="a00231.html#ace99ce94ec9eaa2f7e329d3547a5cb4e">upperMap()</a>, <a class="el" href="a00231.html#af171423e38437c26404bd1f2ece0c83c">costMap()</a>, <a class="el" href="a00231.html#a524e7594df8980eb0edcca44a2625769">supplyMap()</a>, <a class="el" href="a00231.html#ac622127c2be52342b9becb61ff28e56e">stSupply()</a>, <a class="el" href="a00231.html#a40c06e412dc08e6a541abbcf97385b1e">supplyType()</a>. For example, </p>
<div class="fragment"><pre class="fragment">   NetworkSimplex&lt;ListDigraph&gt; ns(graph);
   ns.lowerMap(lower).upperMap(upper).costMap(cost)
     .supplyMap(sup).run();
</pre></div><p>This function can be called more than once. All the given parameters are kept for the next call, unless <a class="el" href="a00231.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> or <a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360">reset()</a> is used, thus only the modified parameters have to be set again. If the underlying digraph was also modified after the construction of the class (or the last <a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360">reset()</a> call), then the <a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360">reset()</a> function must be called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pivot_rule</em>&nbsp;</td><td>The pivot rule that will be used during the algorithm. For more information, see <a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>INFEASIBLE</code> if no feasible flow exists, <br/>
 <code>OPTIMAL</code> if the problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions), <br/>
 <code>UNBOUNDED</code> if the objective function of the problem is unbounded, i.e. there is a directed cycle having negative total cost and infinite upper bound.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00231.html#a4c669cb1cb4d98dfea944e9ceec7d33e" title="Problem type constants for the run() function.">ProblemType</a>, <a class="el" href="a00231.html#a310d3a1fcfff1e099330ae372abc73c2" title="Constants for selecting the pivot rule.">PivotRule</a> </dd>
<dd>
<a class="el" href="a00231.html#aefce8a05d41659d7aaffb4cb47eeec43" title="Reset all the parameters that have been given before.">resetParams()</a>, <a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360" title="Reset the internal data structures and all the parameters that have been given before.">reset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aefce8a05d41659d7aaffb4cb47eeec43"></a><!-- doxytag: member="lemon::NetworkSimplex::resetParams" ref="aefce8a05d41659d7aaffb4cb47eeec43" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html">NetworkSimplex</a>&amp; resetParams </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets all the paramaters that have been given before using functions <a class="el" href="a00231.html#a46572604302ad5db507870c2b11ab004">lowerMap()</a>, <a class="el" href="a00231.html#ace99ce94ec9eaa2f7e329d3547a5cb4e">upperMap()</a>, <a class="el" href="a00231.html#af171423e38437c26404bd1f2ece0c83c">costMap()</a>, <a class="el" href="a00231.html#a524e7594df8980eb0edcca44a2625769">supplyMap()</a>, <a class="el" href="a00231.html#ac622127c2be52342b9becb61ff28e56e">stSupply()</a>, <a class="el" href="a00231.html#a40c06e412dc08e6a541abbcf97385b1e">supplyType()</a>.</p>
<p>It is useful for multiple <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> calls. Basically, all the given parameters are kept for the next <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> call, unless <a class="el" href="a00231.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> or <a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360">reset()</a> call, then the <a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360">reset()</a> function must be used, otherwise <a class="el" href="a00231.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> is sufficient.</p>
<p>For example, </p>
<div class="fragment"><pre class="fragment">   NetworkSimplex&lt;ListDigraph&gt; ns(graph);

   <span class="comment">// First run</span>
   ns.lowerMap(lower).upperMap(upper).costMap(cost)
     .supplyMap(sup).run();

   <span class="comment">// Run again with modified cost map (resetParams() is not called,</span>
   <span class="comment">// so only the cost map have to be set again)</span>
   cost[e] += 100;
   ns.costMap(cost).run();

   <span class="comment">// Run again from scratch using resetParams()</span>
   <span class="comment">// (the lower bounds will be set to zero on all arcs)</span>
   ns.resetParams();
   ns.upperMap(capacity).costMap(cost)
     .supplyMap(sup).run();
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360" title="Reset the internal data structures and all the parameters that have been given before.">reset()</a>, <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53" title="Run the algorithm.">run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a88086127469093e19a9a024bbf60c360"></a><!-- doxytag: member="lemon::NetworkSimplex::reset" ref="a88086127469093e19a9a024bbf60c360" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html">NetworkSimplex</a>&amp; reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets the internal data structures and all the paramaters that have been given before using functions <a class="el" href="a00231.html#a46572604302ad5db507870c2b11ab004">lowerMap()</a>, <a class="el" href="a00231.html#ace99ce94ec9eaa2f7e329d3547a5cb4e">upperMap()</a>, <a class="el" href="a00231.html#af171423e38437c26404bd1f2ece0c83c">costMap()</a>, <a class="el" href="a00231.html#a524e7594df8980eb0edcca44a2625769">supplyMap()</a>, <a class="el" href="a00231.html#ac622127c2be52342b9becb61ff28e56e">stSupply()</a>, <a class="el" href="a00231.html#a40c06e412dc08e6a541abbcf97385b1e">supplyType()</a>.</p>
<p>It is useful for multiple <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> calls. Basically, all the given parameters are kept for the next <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> call, unless <a class="el" href="a00231.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> or <a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360">reset()</a> call, then the <a class="el" href="a00231.html#a88086127469093e19a9a024bbf60c360">reset()</a> function must be used, otherwise <a class="el" href="a00231.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> is sufficient.</p>
<p>See <a class="el" href="a00231.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> for examples.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>(*this)</code></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00231.html#aefce8a05d41659d7aaffb4cb47eeec43" title="Reset all the parameters that have been given before.">resetParams()</a>, <a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53" title="Run the algorithm.">run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a53bae6343367680cea8a37c2f6cd17b3"></a><!-- doxytag: member="lemon::NetworkSimplex::totalCost" ref="a53bae6343367680cea8a37c2f6cd17b3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Number totalCost </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the total cost of the found flow. Its complexity is O(e).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The return type of the function can be specified as a template parameter. For example, <div class="fragment"><pre class="fragment">   ns.totalCost&lt;<span class="keywordtype">double</span>&gt;();
</pre></div> It is useful if the total cost cannot be stored in the <code>Cost</code> type of the algorithm, which is the default return type of the function.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fc53c0667fdfb95dadd6a302f045941"></a><!-- doxytag: member="lemon::NetworkSimplex::flow" ref="a7fc53c0667fdfb95dadd6a302f045941" args="(const Arc &amp;a) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html#a6c1768456283cc436140a9ffae849dd2">Value</a> flow </td>
          <td>(</td>
          <td class="paramtype">const Arc &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the flow on the given arc.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bacd75ff1778bdc0a2c3ab0d0d00f36"></a><!-- doxytag: member="lemon::NetworkSimplex::flowMap" ref="a0bacd75ff1778bdc0a2c3ab0d0d00f36" args="(FlowMap &amp;map) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flowMap </td>
          <td>(</td>
          <td class="paramtype">FlowMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function copies the flow value on each arc into the given map. The <code>Value</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ac97efaa2b500bb002f116bf4ba7c9b0b"></a><!-- doxytag: member="lemon::NetworkSimplex::potential" ref="ac97efaa2b500bb002f116bf4ba7c9b0b" args="(const Node &amp;n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00231.html#adeb81a88e6bbaf933ca20ea3bbba7a2c">Cost</a> potential </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the potential (dual value) of the given node.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a5011146c7986300cf2a684fb7aa8419a"></a><!-- doxytag: member="lemon::NetworkSimplex::potentialMap" ref="a5011146c7986300cf2a684fb7aa8419a" args="(PotentialMap &amp;map) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void potentialMap </td>
          <td>(</td>
          <td class="paramtype">PotentialMap &amp;&nbsp;</td>
          <td class="paramname"> <em>map</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function copies the potential (dual value) of each node into the given map. The <code>Cost</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="a00231.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a601ffd79f13610daacadd46f973507c5"></a><!-- doxytag: member="lemon::NetworkSimplex::INF" ref="a601ffd79f13610daacadd46f973507c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00231.html#a6c1768456283cc436140a9ffae849dd2">Value</a> <a class="el" href="a00231.html#a601ffd79f13610daacadd46f973507c5">INF</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constant for infinite upper bounds (capacities). It is <code>std::numeric_limits&lt;Value&gt;::infinity()</code> if available, <code>std::numeric_limits&lt;Value&gt;::max()</code> otherwise. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
